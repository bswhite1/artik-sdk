/****************************************************************************
 *
 * Copyright 2018 Samsung Electronics All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 ****************************************************************************/
/****************************************************************************
 * Included Files
 ****************************************************************************/

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <artik_security.hh>

#define ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))

/*
 * Definition for handling pthread
 */
#define SECURITY_TEST_PRIORITY     100
#define SECURITY_TEST_STACK_SIZE   51200
#define SECURITY_TEST_SCHED_POLICY SCHED_RR

#define SEE_MAX_BUF_SIZE    4096
#define PEM_BEGIN_CRT       "-----BEGIN CERTIFICATE-----\n"
#define PEM_END_CRT         "-----END CERTIFICATE-----\n"
#define PEM_BEGIN_PUBKEY    "-----BEGIN PUBLIC KEY-----"
#define PEM_END_PUBKEY      "-----END PUBLIC KEY-----"
#define PEM_BEGIN_EC_PRIV_KEY    "-----BEGIN EC PRIVATE KEY-----"
#define PEM_END_EC_PRIV_KEY "-----END EC PRIVATE KEY-----"

typedef enum {
  SEE_OK,

  SEE_ERROR,
  SEE_ALLOC_ERROR,
  SEE_INVALID_INPUT_PARAMS,
  SEE_INVALID_CERT_INDEX,
  SEE_INVALID_KEY_INDEX,
  SEE_INVALID_BUFFER_SIZE,
  SEE_MUTEX_INIT_ERROR,
  SEE_MUTEX_LOCK_ERROR,
  SEE_MUTEX_UNLOCK_ERROR,
  SEE_MUTEX_FREE_ERROR,

  SEE_WRITE_CERT_ERROR,
  SEE_READ_CERT_ERROR,
  SEE_GET_HASH_ERROR,
  SEE_GET_RANDOM_ERROR,
  SEE_ECDSA_SIGN_ERROR,
  SEE_ECDSA_VERIFY_ERROR,
  SEE_ECDH_COMPUTE_ERROR,
} see_error;

#define TEST_RSA_CA_NAME    "00000001"
#define TEST_RSA_DEV_NAME   "00000002"

#define TEST_CERT_PEM       "-----BEGIN CERTIFICATE-----\n"\
      "MIICNzCCAd2gAwIBAgIJAKMtfXi0W6ioMAoGCCqGSM49BAMCMH8xCzAJBgNVBAYT\n"\
      "AktSMRAwDgYDVQQIDAdFbmdsYW5kMSQwIgYDVQQKDBtTYW1zdW5nIFNlbWljb25k\n"\
      "dWN0b3IgQVJUSUsxGzAZBgNVBAsMEkFSVElLIFJvb3QgQ0EgVGVzdDEbMBkGA1UE\n"\
      "AwwSQVJUSUsgUm9vdCBDQSBUZXN0MB4XDTE3MDMxNDA3NTQyMloXDTMyMDMxMDA3\n"\
      "NTQyMlowfzELMAkGA1UEBhMCS1IxEDAOBgNVBAgMB0VuZ2xhbmQxJDAiBgNVBAoM\n"\
      "G1NhbXN1bmcgU2VtaWNvbmR1Y3RvciBBUlRJSzEbMBkGA1UECwwSQVJUSUsgUm9v\n"\
      "dCBDQSBUZXN0MRswGQYDVQQDDBJBUlRJSyBSb290IENBIFRlc3QwWTATBgcqhkjO\n"\
      "PQIBBggqhkjOPQMBBwNCAAS9eeiVxAIIstHpInEhbIhNGNtqvZ3Qr1h1NXbvJeC3\n"\
      "BgCY5LUhOphwb32PjgjvHo+m0BRbdf5Vhq9rMtpP9Uk4o0IwQDAdBgNVHQ4EFgQU\n"\
      "B9ReEry47MDB6Ql+N7TJf/JxGhAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E\n"\
      "BAMCAQYwCgYIKoZIzj0EAwIDSAAwRQIgV2iTYlR/hyWmzxcMf/wU4kOhRCRB2LD2\n"\
      "ICpARpmuz7ECIQCLiRlB9EWS810OrPmcDXYhf2vRJyesqrMJiPTL2SNl0g==\n"\
      "-----END CERTIFICATE-----\n"

static unsigned char rsa2048_sample[] = {
  0x30, 0x82, 0x04, 0xa3, 0x02, 0x01, 0x01, 0x02, 0x82, 0x01, 0x01, 0x00, 0xa2,
  0x64, 0x21, 0xcf, 0x1c, 0xdb, 0x49, 0x6c, 0x44, 0x01, 0xf8, 0xd5, 0x8b, 0x8d,
  0x20, 0xfe, 0x2a, 0x46, 0x4d, 0x29, 0xf4, 0x82, 0x3c, 0xa4, 0x29, 0x7d, 0x6b,
  0xdc, 0xc4, 0x04, 0xd6, 0x0f, 0xf3, 0x6b, 0xa8, 0xb1, 0xad, 0x2b, 0xa1, 0xa5,
  0xad, 0xfb, 0x9a, 0xba, 0x72, 0x6e, 0x4e, 0x71, 0x93, 0x54, 0x8d, 0x90, 0x02,
  0x34, 0x80, 0x1d, 0x8c, 0x83, 0xc9, 0x84, 0xa3, 0xcf, 0x9f, 0x80, 0xe9, 0x4f,
  0x5b, 0xf6, 0x29, 0x17, 0xf6, 0x7f, 0x5a, 0x79, 0x47, 0x0c, 0x2c, 0xcf, 0x98,
  0x88, 0x6a, 0x31, 0x4e, 0x0a, 0x2c, 0x8e, 0x8c, 0xe5, 0xa5, 0x9f, 0xd7, 0x8f,
  0xd0, 0xc1, 0x04, 0x1a, 0xe9, 0x54, 0xa1, 0x36, 0x4e, 0x92, 0x5e, 0x41, 0x9c,
  0x07, 0xc8, 0x48, 0xac, 0x9c, 0x7c, 0xcb, 0xa0, 0x8a, 0x51, 0x52, 0x4f, 0x47,
  0xa2, 0xc8, 0x48, 0xbc, 0xcd, 0x55, 0x85, 0x24, 0xff, 0xfa, 0x58, 0xe6, 0x75,
  0x61, 0x14, 0x1a, 0x82, 0x4e, 0x6b, 0x40, 0x63, 0x9e, 0xef, 0xbd, 0x70, 0x88,
  0x9e, 0xc8, 0x59, 0x89, 0x16, 0x0c, 0x4e, 0x71, 0xec, 0x2d, 0xa4, 0x0b, 0xb3,
  0x20, 0xca, 0x04, 0x5b, 0x37, 0xf6, 0x5c, 0x80, 0x8d, 0x6a, 0xe4, 0x26, 0x95,
  0xe4, 0xd5, 0x35, 0xcd, 0xd3, 0x90, 0x67, 0x48, 0xef, 0x14, 0x8e, 0xc6, 0xcc,
  0x16, 0xdb, 0x7a, 0x96, 0xd6, 0xbf, 0x01, 0xef, 0x5f, 0x8d, 0xee, 0x35, 0xd1,
  0x66, 0xa3, 0x26, 0x96, 0x5e, 0x73, 0x3b, 0x1e, 0xf6, 0x72, 0xc9, 0x78, 0xc8,
  0xdd, 0x81, 0x21, 0x0f, 0x0d, 0xdc, 0x3f, 0x63, 0x7a, 0x92, 0xf1, 0x31, 0x53,
  0xe6, 0x34, 0xd7, 0x70, 0xb0, 0x1d, 0x2f, 0x97, 0xab, 0x44, 0xf1, 0x70, 0x58,
  0x0e, 0xca, 0xab, 0x26, 0x23, 0x39, 0x6e, 0xdb, 0xf5, 0x5a, 0x15, 0x4a, 0x09,
  0x00, 0x7c, 0xe5, 0x82, 0x78, 0xb8, 0xf0, 0xd1, 0x02, 0x01, 0x03, 0x02, 0x82,
  0x01, 0x00, 0x6c, 0x42, 0xc1, 0x34, 0xbd, 0xe7, 0x86, 0x48, 0x2d, 0x56, 0xa5,
  0xe3, 0xb2, 0x5e, 0x15, 0xfe, 0xc6, 0xd9, 0x88, 0xc6, 0xa3, 0x01, 0x7d, 0xc2,
  0xc6, 0x53, 0x9d, 0x3d, 0xd8, 0x03, 0x39, 0x5f, 0xf7, 0x9d, 0x1b, 0x21, 0x1e,
  0x1d, 0x16, 0x6e, 0x73, 0xfd, 0x11, 0xd1, 0xa1, 0x9e, 0xde, 0xf6, 0x62, 0x38,
  0x5e, 0x60, 0x01, 0x78, 0x55, 0x69, 0x08, 0x57, 0xdb, 0xad, 0xc2, 0x8a, 0x6a,
  0x55, 0xf0, 0xdf, 0x92, 0xa4, 0x1b, 0x65, 0x4e, 0xff, 0x91, 0xa6, 0x2f, 0x5d,
  0x73, 0x35, 0x10, 0x5a, 0xf1, 0x76, 0x34, 0x06, 0xc8, 0x5f, 0x08, 0x99, 0x19,
  0x15, 0x3a, 0x5f, 0xe0, 0x80, 0xad, 0x67, 0x46, 0x38, 0x6b, 0x79, 0x89, 0xb6,
  0xe9, 0x81, 0x12, 0xaf, 0xda, 0xdb, 0x1d, 0xbd, 0xa8, 0x87, 0xc0, 0x5c, 0x36,
  0x36, 0xdf, 0x85, 0x17, 0x30, 0x30, 0x7d, 0xde, 0x39, 0x03, 0x6d, 0xff, 0xfb,
  0x2b, 0x5d, 0x42, 0x90, 0x42, 0x03, 0x55, 0xf6, 0xd1, 0xc3, 0xdd, 0x2c, 0xe5,
  0x94, 0x83, 0xf7, 0x35, 0xb8, 0x05, 0xcd, 0xf5, 0xa5, 0xe6, 0x3b, 0xd1, 0xd2,
  0x49, 0xe2, 0xbe, 0x58, 0x7b, 0x6c, 0xc7, 0xd5, 0xf7, 0x36, 0xe4, 0x00, 0xa4,
  0xd6, 0xe9, 0xf6, 0x62, 0x19, 0x36, 0x58, 0xfb, 0xb4, 0x17, 0x0e, 0x97, 0x9a,
  0xba, 0xaa, 0x7d, 0xbd, 0x90, 0xf5, 0x2c, 0x39, 0xeb, 0x86, 0x26, 0xd5, 0xea,
  0xbd, 0xcf, 0xf4, 0x8f, 0x5a, 0xa6, 0x76, 0xde, 0xa7, 0x70, 0x2f, 0x1a, 0x1e,
  0xff, 0x40, 0x39, 0x4d, 0xc0, 0x9f, 0xaa, 0x0a, 0x99, 0x08, 0x68, 0x97, 0x96,
  0xb1, 0xb7, 0x36, 0xe1, 0x46, 0xd5, 0xd6, 0xd0, 0xd1, 0x8f, 0x23, 0x52, 0x19,
  0xb8, 0xfd, 0xd1, 0x47, 0xf4, 0xb2, 0x0d, 0x99, 0xb7, 0x7a, 0xd2, 0x57, 0x01,
  0xde, 0x36, 0x69, 0x53, 0x9f, 0xb6, 0x56, 0xa0, 0x61, 0x89, 0x4b, 0x02, 0x81,
  0x81, 0x00, 0xcf, 0xac, 0xb0, 0x32, 0xdc, 0xa1, 0x1a, 0xb7, 0xc6, 0xe3, 0xb8,
  0xde, 0x0a, 0x70, 0x4b, 0xfa, 0x59, 0xa2, 0x0b, 0x6b, 0x2b, 0xe6, 0x5c, 0xd6,
  0xe4, 0xc8, 0xc9, 0xe5, 0xe8, 0xb7, 0xa5, 0xa3, 0x94, 0xcb, 0x55, 0x74, 0x4e,
  0xfe, 0xdf, 0x82, 0x97, 0xd0, 0x36, 0xee, 0x00, 0x03, 0x8e, 0x86, 0x28, 0xa1,
  0x10, 0xd5, 0xf9, 0x91, 0x0b, 0x7a, 0x3f, 0x4e, 0x11, 0xdc, 0x44, 0x39, 0xbe,
  0xc2, 0x4c, 0x10, 0xaf, 0x76, 0xa4, 0xe2, 0xf6, 0xd2, 0x5a, 0x59, 0x69, 0xbb,
  0x42, 0xb4, 0x65, 0x50, 0xc8, 0xd8, 0x18, 0x44, 0x55, 0x26, 0x66, 0x8d, 0xd4,
  0x6e, 0x9d, 0x42, 0xe7, 0xac, 0x44, 0x3a, 0x4b, 0x4d, 0x71, 0x46, 0x94, 0x05,
  0x19, 0x9b, 0x8f, 0xdc, 0x25, 0x06, 0xef, 0x00, 0xd2, 0xd5, 0x78, 0xe8, 0xf0,
  0x9e, 0xdd, 0x2f, 0xf6, 0xa8, 0x54, 0xdf, 0xb7, 0x34, 0xe3, 0x5d, 0xc9, 0x55,
  0x02, 0x81, 0x81, 0x00, 0xc8, 0x2d, 0xe1, 0x55, 0xd4, 0x74, 0x66, 0xa4, 0x69,
  0xb6, 0xde, 0xfd, 0x8c, 0xee, 0x5e, 0x9b, 0x74, 0x92, 0x45, 0x68, 0xf9, 0xad,
  0x18, 0x41, 0x4c, 0xa9, 0x6b, 0x51, 0xac, 0xe4, 0x6b, 0x3d, 0x9a, 0xab, 0xae,
  0x15, 0xdb, 0x8d, 0x94, 0x1f, 0x2f, 0xd4, 0x1a, 0xc1, 0x64, 0x44, 0xcb, 0x7c,
  0x1c, 0x11, 0xfa, 0xd6, 0x7d, 0x36, 0x04, 0x00, 0x42, 0xbc, 0xc2, 0xa3, 0x99,
  0x7e, 0xf6, 0x5c, 0x61, 0xc0, 0xce, 0x6b, 0xea, 0xb8, 0x36, 0x11, 0xb6, 0x1e,
  0xa9, 0x1d, 0x0c, 0x8f, 0xe5, 0x47, 0xaa, 0x10, 0xc7, 0xed, 0x3a, 0xd7, 0x90,
  0x24, 0xf2, 0x28, 0x93, 0xa3, 0xb6, 0xd5, 0x50, 0x10, 0x4b, 0x61, 0x05, 0x9c,
  0x44, 0xdd, 0x96, 0x82, 0xcc, 0x17, 0x79, 0x1b, 0xec, 0x9f, 0x3e, 0xe7, 0x2d,
  0x4d, 0xaf, 0xd3, 0xfa, 0x18, 0x01, 0xc2, 0xae, 0x2d, 0x9c, 0xcb, 0xa4, 0xc8,
  0xd9, 0x8d, 0x02, 0x81, 0x81, 0x00, 0x8a, 0x73, 0x20, 0x21, 0xe8, 0x6b, 0x67,
  0x25, 0x2f, 0x42, 0x7b, 0x3e, 0xb1, 0xa0, 0x32, 0xa6, 0xe6, 0x6c, 0x07, 0x9c,
  0xc7, 0xee, 0xe8, 0x8f, 0x43, 0x30, 0x86, 0x99, 0x45, 0xcf, 0xc3, 0xc2, 0x63,
  0x32, 0x38, 0xf8, 0x34, 0xa9, 0xea, 0x57, 0x0f, 0xe0, 0x24, 0x9e, 0xaa, 0xad,
  0x09, 0xae, 0xc5, 0xc0, 0xb5, 0xe3, 0xfb, 0xb6, 0x07, 0xa6, 0xd4, 0xde, 0xb6,
  0x92, 0xd8, 0x26, 0x7f, 0x2c, 0x32, 0xb5, 0xca, 0x4f, 0x18, 0x97, 0x4f, 0x36,
  0xe6, 0xe6, 0x46, 0x7c, 0xd7, 0x22, 0xee, 0x35, 0xdb, 0x3a, 0xba, 0xd8, 0x38,
  0xc4, 0x44, 0x5e, 0x8d, 0x9f, 0x13, 0x81, 0xef, 0xc8, 0x2d, 0x7c, 0x32, 0x33,
  0xa0, 0xd9, 0xb8, 0x03, 0x66, 0x67, 0xb5, 0x3d, 0x6e, 0x04, 0x9f, 0x55, 0xe1,
  0xe3, 0xa5, 0xf0, 0xa0, 0x69, 0xe8, 0xca, 0xa4, 0x70, 0x38, 0x95, 0x24, 0xcd,
  0xec, 0xe9, 0x30, 0xe3, 0x02, 0x81, 0x81, 0x00, 0x85, 0x73, 0xeb, 0x8e, 0x8d,
  0xa2, 0xef, 0x18, 0x46, 0x79, 0xe9, 0xfe, 0x5d, 0xf4, 0x3f, 0x12, 0x4d, 0xb6,
  0xd8, 0xf0, 0xa6, 0x73, 0x65, 0x80, 0xdd, 0xc6, 0x47, 0x8b, 0xc8, 0x98, 0x47,
  0x7e, 0x67, 0x1d, 0x1e, 0xb9, 0x3d, 0x09, 0x0d, 0x6a, 0x1f, 0xe2, 0xbc, 0x80,
  0xed, 0x83, 0x32, 0x52, 0xbd, 0x61, 0x51, 0xe4, 0x53, 0x79, 0x58, 0x00, 0x2c,
  0x7d, 0xd7, 0x17, 0xbb, 0xa9, 0xf9, 0x92, 0xeb, 0xd5, 0xde, 0xf2, 0x9c, 0x7a,
  0xce, 0xb6, 0x79, 0x69, 0xc6, 0x13, 0x5d, 0xb5, 0x43, 0x85, 0x1c, 0x0b, 0x2f,
  0xf3, 0x7c, 0x8f, 0xb5, 0x6d, 0xf6, 0xc5, 0xb7, 0xc2, 0x79, 0xe3, 0x8a, 0xb5,
  0x87, 0x96, 0x03, 0xbd, 0x83, 0x3e, 0x64, 0x57, 0x32, 0xba, 0x50, 0xbd, 0x48,
  0x6a, 0x29, 0xef, 0x73, 0x89, 0x1f, 0xe2, 0xa6, 0xba, 0xab, 0xd7, 0x1e, 0xc9,
  0x13, 0x32, 0x6d, 0xdb, 0x3b, 0xb3, 0x02, 0x81, 0x81, 0x00, 0xa9, 0xe4, 0xa3,
  0x54, 0x03, 0x2f, 0xc2, 0x8d, 0xa2, 0x1e, 0xae, 0xe0, 0xfb, 0xe9, 0xba, 0xe0,
  0xb5, 0xb6, 0x69, 0x0d, 0xe3, 0x8e, 0xeb, 0x0a, 0x29, 0x9d, 0x15, 0xc2, 0x8a,
  0x76, 0x96, 0x4e, 0x77, 0xea, 0x1a, 0x0b, 0xe8, 0x9b, 0x5d, 0xf7, 0xbd, 0x86,
  0xfb, 0xe4, 0x6b, 0x3c, 0x32, 0xc6, 0x7a, 0xfe, 0xf7, 0x5f, 0xec, 0x2e, 0x24,
  0xfa, 0x68, 0xac, 0xf2, 0xa5, 0x32, 0x4d, 0xd8, 0xd3, 0x68, 0xfa, 0xde, 0xcc,
  0x37, 0x38, 0xa8, 0x3b, 0x4e, 0xeb, 0xae, 0x25, 0xca, 0xb7, 0xc0, 0x80, 0x70,
  0x58, 0xea, 0xc3, 0x52, 0xaa, 0x24, 0x3c, 0x24, 0x17, 0x47, 0x37, 0x70, 0xf9,
  0x45, 0x83, 0x20, 0xce, 0x92, 0xe2, 0x6b, 0x58, 0xfd, 0xa2, 0x90, 0x5b, 0x68,
  0x4c, 0x7e, 0x1a, 0x9b, 0xcd, 0x94, 0xef, 0x4b, 0xe8, 0x8d, 0x9b, 0xf8, 0x38,
  0x6e, 0x1e, 0x12, 0xa5, 0xaf, 0xd3, 0xf0, 0xbd
};

static unsigned char rsa1024_sample[] = {
  0x30, 0x82, 0x02, 0x5B, 0x02, 0x01, 0x00, 0x02, 0x81, 0x81, 0x00, 0xC1, 0x62,
  0xAF, 0x64, 0x69, 0xEB, 0x4A, 0x2E, 0x37, 0x98, 0xA1, 0x3B, 0x1D, 0xA8, 0xD7,
  0xFD, 0xA8, 0xDC, 0xB4, 0x31, 0xCE, 0xD2, 0xB9, 0x48, 0x29, 0x21, 0x92, 0xC7,
  0xE5, 0x8D, 0xA7, 0xCD, 0x15, 0xEA, 0xB9, 0x41, 0x87, 0xAA, 0xB9, 0x08, 0x07,
  0x69, 0x3A, 0x28, 0xC7, 0x28, 0x28, 0xE9, 0x3C, 0x85, 0x61, 0x13, 0xAC, 0xBB,
  0x01, 0x35, 0xE8, 0xC5, 0xF3, 0x91, 0x4C, 0x2C, 0x3D, 0xE1, 0xD5, 0xF8, 0x4B,
  0xA0, 0x28, 0xE2, 0x4A, 0x6B, 0x07, 0xBF, 0x4D, 0xDD, 0x5F, 0x3F, 0xDC, 0x1C,
  0x9A, 0xF5, 0xCD, 0xDC, 0x7B, 0xAD, 0xB5, 0x8C, 0x15, 0x4A, 0x77, 0xEC, 0x0F,
  0x91, 0x0C, 0xEF, 0x57, 0x85, 0x82, 0xE3, 0x9A, 0x1A, 0x46, 0x6B, 0x67, 0xA7,
  0x3C, 0xEB, 0xA7, 0xDF, 0x60, 0xB5, 0xDA, 0xAB, 0x9B, 0xEF, 0xA0, 0xCB, 0xBD,
  0x0E, 0x82, 0x32, 0x15, 0x44, 0xB9, 0xBC, 0x5F, 0x05, 0x02, 0x03, 0x01, 0x00,
  0x01, 0x02, 0x81, 0x80, 0x1D, 0x0D, 0xAC, 0x78, 0x13, 0x89, 0xAB, 0xED, 0x61,
  0xA0, 0xE6, 0xA8, 0x30, 0xFE, 0x8A, 0xE4, 0xAB, 0x17, 0xED, 0x62, 0x86, 0x46,
  0x16, 0x5C, 0x07, 0x01, 0xEA, 0x41, 0x69, 0xF5, 0x6C, 0x3E, 0x5D, 0x8A, 0x94,
  0x26, 0x8A, 0x31, 0x55, 0xF7, 0x24, 0xD5, 0xE4, 0x4C, 0xF8, 0x0E, 0xCA, 0x86,
  0xAF, 0xF7, 0x01, 0xEC, 0xA8, 0xC8, 0xB7, 0x97, 0xD7, 0xCE, 0xD5, 0x97, 0x00,
  0xB0, 0xAC, 0xE3, 0x1B, 0xD1, 0xAD, 0x98, 0xEC, 0x7C, 0x44, 0x96, 0xD2, 0xDD,
  0x0C, 0x85, 0x22, 0x07, 0xF4, 0xCC, 0x7A, 0x38, 0x82, 0x18, 0x79, 0xC8, 0x71,
  0x15, 0x67, 0xB6, 0xAB, 0x07, 0xB9, 0xC7, 0x95, 0xE7, 0x0D, 0x4A, 0xE9, 0x8E,
  0x6A, 0x78, 0xB4, 0xCB, 0x47, 0xB8, 0xC1, 0x35, 0x0E, 0xB3, 0xD0, 0xB9, 0x64,
  0xCF, 0xFF, 0x08, 0xDB, 0x86, 0xB2, 0x05, 0x7D, 0xB6, 0x11, 0xE8, 0x35, 0xBA,
  0x92, 0xC9, 0x02, 0x41, 0x00, 0xF4, 0x67, 0xC2, 0xC8, 0x3F, 0xF2, 0x68, 0xDD,
  0xFA, 0x21, 0xE5, 0xCD, 0x8F, 0xFA, 0xFA, 0xFE, 0x42, 0xBA, 0x93, 0x42, 0x7A,
  0x72, 0x5C, 0x54, 0xC3, 0xEE, 0x98, 0x4C, 0x7F, 0x60, 0xAB, 0x08, 0x96, 0xDC,
  0x3D, 0xDC, 0xB7, 0xDC, 0x2E, 0xB5, 0xC3, 0xB9, 0xA0, 0x5A, 0x12, 0xAE, 0x61,
  0xFD, 0x86, 0x7C, 0xAC, 0x0C, 0x26, 0xD8, 0xC5, 0x86, 0x41, 0x5C, 0xF6, 0x10,
  0xA0, 0xFA, 0x3F, 0xA7, 0x02, 0x41, 0x00, 0xCA, 0x8F, 0x4D, 0x3C, 0x1D, 0x02,
  0xC8, 0x0A, 0xCE, 0x2D, 0x5C, 0x5B, 0x5A, 0x3D, 0x29, 0x63, 0x6D, 0x5E, 0xBC,
  0xBB, 0xE9, 0x99, 0x7F, 0xDB, 0x4E, 0xC1, 0xC6, 0x99, 0xC5, 0x24, 0xCB, 0x64,
  0xFA, 0xBF, 0x3E, 0x70, 0xB4, 0x66, 0x91, 0x7E, 0xEC, 0x0D, 0x69, 0x74, 0xEE,
  0xC4, 0x1E, 0xC5, 0xE9, 0xC0, 0xE8, 0x46, 0x36, 0x19, 0x82, 0xE3, 0xBA, 0xC9,
  0x2B, 0xEF, 0xB9, 0xA0, 0xE1, 0x73, 0x02, 0x40, 0x1F, 0xEB, 0x39, 0x2E, 0x0B,
  0xE3, 0xED, 0xBC, 0x27, 0xC1, 0xAB, 0x90, 0x78, 0x20, 0x50, 0x0D, 0x4A, 0xCB,
  0xB1, 0x15, 0xBA, 0x86, 0x1A, 0xF6, 0xDB, 0x0B, 0xDB, 0x0A, 0x0A, 0x8C, 0xA6,
  0x69, 0x9D, 0xC2, 0x2F, 0xB6, 0x16, 0xB1, 0x03, 0xCC, 0xAB, 0x3E, 0x1F, 0xEA,
  0x03, 0x8C, 0x90, 0xB1, 0x9A, 0x91, 0xC7, 0xAA, 0x62, 0x9C, 0x66, 0xD7, 0x8C,
  0xCB, 0xC6, 0x3B, 0x0F, 0xBA, 0xFE, 0xFB, 0x02, 0x40, 0x38, 0x70, 0xC7, 0x8F,
  0x89, 0x71, 0xDD, 0xF5, 0x8C, 0xCF, 0x7C, 0xDD, 0x83, 0x7E, 0x69, 0x4A, 0xE8,
  0x0D, 0xAE, 0xBF, 0x19, 0x6F, 0x08, 0xFE, 0x3D, 0xAA, 0xA6, 0xC0, 0xEF, 0xFA,
  0xB9, 0xA5, 0xD0, 0x6C, 0x7B, 0x64, 0x82, 0x0F, 0xD6, 0x58, 0xAC, 0x43, 0x6C,
  0x70, 0x05, 0x9B, 0xA6, 0x0B, 0x75, 0x7F, 0xA7, 0xF8, 0xF0, 0x58, 0x19, 0x6D,
  0x84, 0xFD, 0x4A, 0xFD, 0xC8, 0x16, 0x78, 0xDB, 0x02, 0x40, 0x4C, 0x50, 0x6F,
  0xC9, 0x9E, 0x54, 0xCF, 0xD5, 0x01, 0xAA, 0x8E, 0xBB, 0x49, 0xB5, 0x8D, 0x41,
  0x8B, 0xF1, 0xE3, 0xFA, 0xF8, 0x3D, 0x32, 0xA0, 0x61, 0xA2, 0x88, 0x3C, 0x7E,
  0x7E, 0x6F, 0xCA, 0x9C, 0xBC, 0x2C, 0x8A, 0x68, 0xFB, 0x1B, 0x87, 0x54, 0x0E,
  0xED, 0x58, 0x4B, 0x5D, 0x92, 0xEA, 0x52, 0xBF, 0xF7, 0x89, 0x41, 0xE9, 0xC1,
  0x54, 0x31, 0xEA, 0x92, 0x96, 0xF2, 0x43, 0x01, 0xBD
};

static unsigned char test_ecdsa_dev_bp[122] = {
  0x30, 0x78, 0x02, 0x01, 0x01, 0x04, 0x20, 0x1e, 0x20, 0xd3, 0xa6, 0xaa, 0x38,
  0xf6, 0xf1, 0x65, 0x19, 0xb8, 0xae, 0x31, 0x86, 0x7a, 0x47, 0x3b, 0xaf, 0x5e,
  0x54, 0x93, 0xb1, 0x46, 0xba, 0x8d, 0x39, 0x25, 0xa9, 0xe4, 0xd2, 0x41, 0x66,
  0xa0, 0x0b, 0x06, 0x09, 0x2b, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07,
  0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x1a, 0xbc, 0xb3, 0x24, 0xa4, 0x1e, 0x89,
  0x79, 0x6e, 0xbe, 0x75, 0x7f, 0x78, 0xa7, 0x32, 0x21, 0xae, 0x7b, 0xb5, 0xe4,
  0xa4, 0x4d, 0x07, 0x44, 0x0e, 0x07, 0x5a, 0x77, 0x3d, 0xb3, 0xd8, 0xfc, 0x65,
  0x02, 0xfc, 0xd7, 0x1a, 0x3c, 0xcb, 0x9a, 0x4e, 0x34, 0xde, 0x32, 0xe8, 0x3e,
  0x2e, 0xda, 0x09, 0xe0, 0x5f, 0x24, 0x7b, 0x86, 0x83, 0x08, 0xc3, 0xf6, 0x7f,
  0xe3, 0x81, 0xbb, 0xda, 0x62
};

static unsigned char test_ecdsa_dev_nist[223] = {
  0x30, 0x81, 0xdc, 0x02, 0x01, 0x01, 0x04, 0x42, 0x00, 0x94, 0x4f, 0x20, 0xa2,
  0x5b, 0x75, 0xcb, 0x2d, 0xc6, 0x17, 0xd1, 0xd9, 0x04, 0xb5, 0x19, 0x4b, 0xfd,
  0x80, 0x8f, 0xd8, 0x6f, 0xc0, 0x23, 0x2f, 0x23, 0x90, 0xe8, 0x29, 0xa9, 0x9e,
  0x28, 0x0b, 0x8d, 0xa8, 0xf2, 0xb5, 0x4a, 0x7d, 0xc8, 0x09, 0x79, 0xb7, 0xb4,
  0xc4, 0x6e, 0xb4, 0x95, 0x35, 0xbe, 0xcd, 0x19, 0x96, 0x9b, 0x3c, 0xae, 0x50,
  0x2c, 0x98, 0x77, 0x47, 0x0c, 0x7f, 0x87, 0x3b, 0xbd, 0xa0, 0x07, 0x06, 0x05,
  0x2b, 0x81, 0x04, 0x00, 0x23, 0xa1, 0x81, 0x89, 0x03, 0x81, 0x86, 0x00, 0x04,
  0x00, 0xa7, 0xe3, 0x75, 0x81, 0x42, 0x82, 0x15, 0x7c, 0x36, 0xff, 0x46, 0x43,
  0x78, 0x9f, 0x94, 0x99, 0x5c, 0xba, 0x59, 0x90, 0xdc, 0x2a, 0xed, 0x90, 0xbb,
  0x87, 0x07, 0x99, 0x69, 0x17, 0xa5, 0x1d, 0x38, 0x71, 0xc9, 0x91, 0x0e, 0x9c,
  0xa6, 0x35, 0x30, 0x91, 0x1e, 0x98, 0x07, 0x5c, 0xfd, 0xe2, 0x8c, 0x44, 0x16,
  0xc3, 0xc4, 0x2b, 0x03, 0xf0, 0x3b, 0xd7, 0xdc, 0x26, 0xcb, 0x82, 0xe5, 0xcd,
  0x47, 0x01, 0xc3, 0x01, 0xa9, 0xd6, 0xe3, 0xe3, 0x65, 0x4a, 0x8d, 0x23, 0xff,
  0xb4, 0xaa, 0xa6, 0x32, 0x30, 0x63, 0x8c, 0x31, 0x1a, 0x83, 0xa7, 0xd6, 0xd1,
  0xf1, 0xd2, 0x50, 0xbf, 0xd5, 0x51, 0x3b, 0x74, 0x13, 0x71, 0x79, 0x1b, 0x55,
  0x34, 0x2b, 0xae, 0x98, 0x40, 0x32, 0xcc, 0xf4, 0xae, 0xc5, 0xe3, 0xd3, 0x03,
  0xcf, 0x8f, 0x36, 0xeb, 0x2c, 0xc8, 0x0a, 0xc7, 0xad, 0x88, 0x24, 0x9f, 0x00,
  0xd4, 0x18
};

static unsigned char test_ecdsa_256_dev_nist[121] = {
  0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0xDA, 0x51, 0x77, 0x3A, 0xCB, 0x81,
  0xAF, 0x18, 0x2A, 0xE4, 0x72, 0xBE, 0xD6, 0x76, 0x80, 0xFC, 0xE3, 0x87, 0x60,
  0x31, 0x2B, 0x00, 0x4E, 0x8B, 0x1C, 0xAB, 0x12, 0x57, 0xE8, 0x86, 0xF5, 0xA1,
  0xA0, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0xA1,
  0x44, 0x03, 0x42, 0x00, 0x04, 0x6E, 0xFA, 0x3D, 0x85, 0xC6, 0x14, 0x9C, 0x77,
  0x44, 0x65, 0xDC, 0x5C, 0x8B, 0xD8, 0xAE, 0x95, 0xD4, 0x50, 0x69, 0xAF, 0xD3,
  0x85, 0x14, 0x00, 0x01, 0xEB, 0x37, 0x76, 0xE0, 0xCE, 0x68, 0x8C, 0x9E, 0x5C,
  0x50, 0x18, 0x57, 0xA4, 0xFC, 0x03, 0x5A, 0x08, 0x0B, 0x4F, 0x89, 0x77, 0x3D,
  0xD9, 0x55, 0xAF, 0x17, 0xD3, 0x6D, 0xA3, 0x75, 0xD3, 0xFE, 0x61, 0x42, 0xD0,
  0xCB, 0xFB, 0xAA, 0xAC
};

static unsigned char test_ecdsa_384_dev_nist[167] = {
  0x30, 0x81, 0xa4, 0x02, 0x01, 0x01, 0x04, 0x30, 0x48, 0x0c, 0x60, 0x20, 0xb0,
  0x11, 0x11, 0x11, 0x6d, 0x41, 0xbb, 0x43, 0xf7, 0x21, 0xe4, 0x33, 0x8f, 0x6b,
  0x0e, 0x88, 0x7e, 0xff, 0x84, 0xa8, 0x37, 0x76, 0xb2, 0x89, 0x71, 0xe7, 0x42,
  0x3f, 0xaa, 0x49, 0x9c, 0x30, 0x9f, 0x13, 0xc9, 0xc8, 0x4f, 0x06, 0xfe, 0xad,
  0x69, 0x5c, 0x1c, 0x94, 0xA0, 0x07, 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22,
  0xA1, 0x64, 0x03, 0x62, 0x00, 0x04, 0x45, 0x59, 0x6D, 0x6E, 0x5C, 0x7A, 0x60,
  0x72, 0xE2, 0xA2, 0xDE, 0x2D, 0x4C, 0x45, 0xAA, 0x2C, 0x74, 0xA5, 0x3A, 0x2C,
  0x42, 0x04, 0xBD, 0x61, 0x87, 0x90, 0xDB, 0xCB, 0x4A, 0xD4, 0x02, 0xC6, 0xBE,
  0x76, 0x44, 0x6B, 0xA7, 0x33, 0x96, 0xA5, 0x26, 0x77, 0x87, 0x1B, 0x79, 0xA7,
  0xB2, 0x6A, 0xBA, 0x07, 0xDA, 0xE5, 0x6C, 0x5D, 0x12, 0x5A, 0x44, 0xDB, 0xC2,
  0xB6, 0x0C, 0x13, 0xD0, 0xE6, 0x51, 0xA9, 0x01, 0x11, 0xA4, 0x5A, 0x52, 0x41,
  0x61, 0xF0, 0x4F, 0x23, 0x7C, 0xAE, 0xBC, 0x07, 0xD7, 0x96, 0x7B, 0xD1, 0x7A,
  0x62, 0xD8, 0xE1, 0x4D, 0xFB, 0xA1, 0x4F, 0xCC, 0x5C, 0x7E, 0x8A
};

static unsigned char dh1024_key[] = {
      0x30, 0x82, 0x01, 0x21, 0x02, 0x01, 0x00, 0x30, 0x81, 0x95, 0x06, 0x09,
      0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x03, 0x01, 0x30, 0x81, 0x87,
      0x02, 0x81, 0x81, 0x00, 0xf4, 0x50, 0x46, 0xbb, 0xc8, 0x4a, 0x6c, 0x63,
      0xb4, 0xad, 0xe7, 0x94, 0xa6, 0x9f, 0x84, 0x04, 0x39, 0xf8, 0x5f, 0xe5,
      0x2d, 0xb0, 0x90, 0xea, 0x25, 0xc1, 0xee, 0x18, 0xd1, 0xa8, 0x2e, 0x7f,
      0xd8, 0xba, 0x3d, 0x75, 0x81, 0xce, 0x7b, 0x15, 0xfd, 0x50, 0xe7, 0x6c,
      0x0b, 0x16, 0xaa, 0xea, 0x05, 0x49, 0x12, 0xe3, 0x5a, 0x1c, 0x38, 0xf0,
      0x17, 0x44, 0x80, 0xb8, 0xbc, 0x4f, 0x3d, 0x1f, 0xb8, 0x38, 0x0e, 0xda,
      0x8f, 0xa9, 0xbb, 0x73, 0x0b, 0x1d, 0x50, 0x25, 0x54, 0x0e, 0xcb, 0x81,
      0xa8, 0xad, 0xe1, 0xaf, 0xfe, 0xe0, 0x61, 0x35, 0xc8, 0x90, 0xdc, 0x86,
      0xd2, 0xc5, 0x84, 0xc3, 0xbf, 0xb3, 0x32, 0x32, 0x15, 0xbb, 0x63, 0xae,
      0xb5, 0x3e, 0xc6, 0x3a, 0x91, 0xc0, 0x96, 0x2b, 0x4e, 0x60, 0xec, 0x1e,
      0x20, 0x0a, 0x23, 0x4f, 0xee, 0xea, 0x5f, 0x0f, 0xb7, 0xe0, 0x94, 0xdb,
      0x02, 0x01, 0x02, 0x04, 0x81, 0x83, 0x02, 0x81, 0x80, 0x68, 0x16, 0x49,
      0xeb, 0xc5, 0x10, 0x6b, 0x0e, 0xcd, 0xbb, 0x04, 0xdf, 0xfc, 0x22, 0x51,
      0x17, 0x99, 0x13, 0xb3, 0xf0, 0xf7, 0x82, 0xb4, 0x8e, 0xa7, 0xfa, 0xec,
      0x5e, 0xd1, 0xd7, 0x9f, 0x66, 0x5b, 0x20, 0x55, 0xb5, 0x0e, 0xc1, 0xcc,
      0x56, 0x66, 0x89, 0x76, 0xaa, 0xc2, 0x4f, 0x1f, 0x59, 0x38, 0xbc, 0x24,
      0x27, 0x9f, 0x74, 0xc8, 0x84, 0x5f, 0xc8, 0x15, 0xa5, 0xb3, 0xcc, 0x85,
      0xb3, 0x2e, 0xfb, 0xca, 0x0a, 0xc9, 0x24, 0xc6, 0xb5, 0xc2, 0x38, 0xa4,
      0xff, 0xf4, 0xc8, 0x03, 0xdb, 0x65, 0x53, 0x1e, 0x4c, 0xad, 0x63, 0x30,
      0xf7, 0x4e, 0xa4, 0xdc, 0x85, 0xb8, 0x76, 0x08, 0x4b, 0xa3, 0x10, 0xf8,
      0xdf, 0xc4, 0x41, 0x3c, 0x60, 0x66, 0xc2, 0xf3, 0x7e, 0xd6, 0x6b, 0x71,
      0x81, 0xda, 0xcb, 0x99, 0x4d, 0xb4, 0x72, 0x0d, 0xfd, 0xa5, 0xa0, 0x2f,
      0xc6, 0x57, 0xe3, 0x7e, 0x32
  };

static unsigned char dh1024_key_pub[] = {
       0x30, 0x82, 0x01, 0x1f, 0x30, 0x81, 0x95, 0x06, 0x09, 0x2a, 0x86, 0x48,
       0x86, 0xf7, 0x0d, 0x01, 0x03, 0x01, 0x30, 0x81, 0x87, 0x02, 0x81, 0x81,
       0x00, 0xf4, 0x50, 0x46, 0xbb, 0xc8, 0x4a, 0x6c, 0x63, 0xb4, 0xad, 0xe7,
       0x94, 0xa6, 0x9f, 0x84, 0x04, 0x39, 0xf8, 0x5f, 0xe5, 0x2d, 0xb0, 0x90,
       0xea, 0x25, 0xc1, 0xee, 0x18, 0xd1, 0xa8, 0x2e, 0x7f, 0xd8, 0xba, 0x3d,
       0x75, 0x81, 0xce, 0x7b, 0x15, 0xfd, 0x50, 0xe7, 0x6c, 0x0b, 0x16, 0xaa,
       0xea, 0x05, 0x49, 0x12, 0xe3, 0x5a, 0x1c, 0x38, 0xf0, 0x17, 0x44, 0x80,
       0xb8, 0xbc, 0x4f, 0x3d, 0x1f, 0xb8, 0x38, 0x0e, 0xda, 0x8f, 0xa9, 0xbb,
       0x73, 0x0b, 0x1d, 0x50, 0x25, 0x54, 0x0e, 0xcb, 0x81, 0xa8, 0xad, 0xe1,
       0xaf, 0xfe, 0xe0, 0x61, 0x35, 0xc8, 0x90, 0xdc, 0x86, 0xd2, 0xc5, 0x84,
       0xc3, 0xbf, 0xb3, 0x32, 0x32, 0x15, 0xbb, 0x63, 0xae, 0xb5, 0x3e, 0xc6,
       0x3a, 0x91, 0xc0, 0x96, 0x2b, 0x4e, 0x60, 0xec, 0x1e, 0x20, 0x0a, 0x23,
       0x4f, 0xee, 0xea, 0x5f, 0x0f, 0xb7, 0xe0, 0x94, 0xdb, 0x02, 0x01, 0x02,
       0x03, 0x81, 0x84, 0x00, 0x02, 0x81, 0x80, 0x04, 0xb0, 0x65, 0xdb, 0x09,
       0x04, 0x28, 0xa7, 0x71, 0x51, 0xdb, 0x9a, 0xf7, 0xb9, 0xfd, 0x1d, 0x31,
       0x12, 0x79, 0xa2, 0xf0, 0xce, 0x8b, 0x5b, 0x4c, 0x94, 0x99, 0x7e, 0x60,
       0xb6, 0x10, 0xc3, 0x4b, 0x93, 0xb6, 0x98, 0xb1, 0xa3, 0x0c, 0xe0, 0x78,
       0xd3, 0xd1, 0x99, 0x8b, 0x83, 0x59, 0x96, 0x4b, 0x5b, 0x3c, 0x7c, 0x2f,
       0xbe, 0xab, 0x13, 0x16, 0x51, 0xba, 0x8c, 0x98, 0x52, 0xb4, 0x6c, 0x00,
       0x34, 0x8e, 0x17, 0xd7, 0xad, 0x73, 0x4f, 0x4f, 0x3e, 0xea, 0x7f, 0xa9,
       0x3e, 0x89, 0x88, 0x6c, 0x79, 0x38, 0xe4, 0xf2, 0xb2, 0x66, 0xa6, 0xac,
       0xbc, 0x75, 0x70, 0x21, 0x21, 0xe8, 0x7a, 0x3d, 0x42, 0x56, 0x2d, 0x3f,
       0x84, 0xe7, 0x91, 0xe2, 0x40, 0x20, 0x6d, 0x0f, 0x12, 0xa2, 0x33, 0x61,
       0xf5, 0x7a, 0x54, 0x1d, 0xb7, 0x81, 0x5e, 0xfd, 0xa7, 0xc0, 0xe4, 0x06,
       0x19, 0x13, 0x05
  };

static unsigned char dh1024_secret[] = {
      0x2f, 0xe8, 0x10, 0x87, 0x29, 0x13, 0x89, 0x63, 0xfb, 0x4c, 0xbe, 0xd0,
      0x43, 0xd6, 0x90, 0x86, 0xd0, 0x15, 0xbc, 0x19, 0x0f, 0xdc, 0x95, 0x07,
      0x9d, 0x52, 0xee, 0x95, 0xdd, 0xe8, 0x22, 0x8c, 0xc0, 0x63, 0x4b, 0xd8,
      0xab, 0x60, 0xcb, 0xce, 0xe7, 0xbf, 0x53, 0x9b, 0x2a, 0x87, 0x49, 0xd7,
      0xae, 0xf9, 0xcd, 0x5c, 0xa9, 0x24, 0x4d, 0x20, 0x4f, 0xa7, 0xad, 0xb5,
      0xc6, 0xe0, 0x49, 0xf3, 0xe7, 0xf5, 0xb0, 0xe1, 0xcb, 0xda, 0xc2, 0x7b,
      0x43, 0x2c, 0x8d, 0xfa, 0xa7, 0x68, 0xa1, 0xc5, 0x89, 0x8e, 0x33, 0x83,
      0xcd, 0x69, 0xe7, 0x22, 0x7e, 0x0a, 0x8b, 0x3f, 0x78, 0x9d, 0xb5, 0x38,
      0x0f, 0xee, 0xaa, 0xae, 0x25, 0x56, 0xf7, 0x5f, 0x3c, 0x48, 0x18, 0xaf,
      0x21, 0xec, 0xad, 0x33, 0xa8, 0x7f, 0xf3, 0x6f, 0x34, 0x55, 0xd4, 0x4f,
      0x25, 0xc1, 0x07, 0x7f, 0xe4, 0x60, 0x78, 0x59
  };

static unsigned char dh1024_5114_key[] = {
      0x30, 0x82, 0x01, 0x4B, 0x02, 0x01, 0x00, 0x30, 0x82, 0x01, 0x2C, 0x06,
      0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3E, 0x02, 0x01, 0x30, 0x82, 0x01, 0x1F,
      0x02, 0x81, 0x81, 0x00, 0xB1, 0x0B, 0x8F, 0x96, 0xA0, 0x80, 0xE0, 0x1D,
      0xDE, 0x92, 0xDE, 0x5E, 0xAE, 0x5D, 0x54, 0xEC, 0x52, 0xC9, 0x9F, 0xBC,
      0xFB, 0x06, 0xA3, 0xC6, 0x9A, 0x6A, 0x9D, 0xCA, 0x52, 0xD2, 0x3B, 0x61,
      0x60, 0x73, 0xE2, 0x86, 0x75, 0xA2, 0x3D, 0x18, 0x98, 0x38, 0xEF, 0x1E,
      0x2E, 0xE6, 0x52, 0xC0, 0x13, 0xEC, 0xB4, 0xAE, 0xA9, 0x06, 0x11, 0x23,
      0x24, 0x97, 0x5C, 0x3C, 0xD4, 0x9B, 0x83, 0xBF, 0xAC, 0xCB, 0xDD, 0x7D,
      0x90, 0xC4, 0xBD, 0x70, 0x98, 0x48, 0x8E, 0x9C, 0x21, 0x9A, 0x73, 0x72,
      0x4E, 0xFF, 0xD6, 0xFA, 0xE5, 0x64, 0x47, 0x38, 0xFA, 0xA3, 0x1A, 0x4F,
      0xF5, 0x5B, 0xCC, 0xC0, 0xA1, 0x51, 0xAF, 0x5F, 0x0D, 0xC8, 0xB4, 0xBD,
      0x45, 0xBF, 0x37, 0xDF, 0x36, 0x5C, 0x1A, 0x65, 0xE6, 0x8C, 0xFD, 0xA7,
      0x6D, 0x4D, 0xA7, 0x08, 0xDF, 0x1F, 0xB2, 0xBC, 0x2E, 0x4A, 0x43, 0x71,
      0x02, 0x81, 0x81, 0x00, 0xA4, 0xD1, 0xCB, 0xD5, 0xC3, 0xFD, 0x34, 0x12,
      0x67, 0x65, 0xA4, 0x42, 0xEF, 0xB9, 0x99, 0x05, 0xF8, 0x10, 0x4D, 0xD2,
      0x58, 0xAC, 0x50, 0x7F, 0xD6, 0x40, 0x6C, 0xFF, 0x14, 0x26, 0x6D, 0x31,
      0x26, 0x6F, 0xEA, 0x1E, 0x5C, 0x41, 0x56, 0x4B, 0x77, 0x7E, 0x69, 0x0F,
      0x55, 0x04, 0xF2, 0x13, 0x16, 0x02, 0x17, 0xB4, 0xB0, 0x1B, 0x88, 0x6A,
      0x5E, 0x91, 0x54, 0x7F, 0x9E, 0x27, 0x49, 0xF4, 0xD7, 0xFB, 0xD7, 0xD3,
      0xB9, 0xA9, 0x2E, 0xE1, 0x90, 0x9D, 0x0D, 0x22, 0x63, 0xF8, 0x0A, 0x76,
      0xA6, 0xA2, 0x4C, 0x08, 0x7A, 0x09, 0x1F, 0x53, 0x1D, 0xBF, 0x0A, 0x01,
      0x69, 0xB6, 0xA2, 0x8A, 0xD6, 0x62, 0xA4, 0xD1, 0x8E, 0x73, 0xAF, 0xA3,
      0x2D, 0x77, 0x9D, 0x59, 0x18, 0xD0, 0x8B, 0xC8, 0x85, 0x8F, 0x4D, 0xCE,
      0xF9, 0x7C, 0x2A, 0x24, 0x85, 0x5E, 0x6E, 0xEB, 0x22, 0xB3, 0xB2, 0xE5,
      0x02, 0x15, 0x00, 0xF5, 0x18, 0xAA, 0x87, 0x81, 0xA8, 0xDF, 0x27, 0x8A,
      0xBA, 0x4E, 0x7D, 0x64, 0xB7, 0xCB, 0x9D, 0x49, 0x46, 0x23, 0x53, 0x04,
      0x16, 0x02, 0x14, 0x45, 0x6B, 0x6A, 0xAB, 0xD2, 0x36, 0x4E, 0x50, 0x89,
      0xA3, 0x02, 0x01, 0x63, 0xCC, 0xCB, 0xAE, 0x04, 0x9E, 0x84, 0xDC
  };

static unsigned char dh1024_5114_key_pub[] = {
      0x30, 0x82, 0x01, 0xB7, 0x30, 0x82, 0x01, 0x2C, 0x06, 0x07, 0x2A, 0x86,
      0x48, 0xCE, 0x3E, 0x02, 0x01, 0x30, 0x82, 0x01, 0x1F, 0x02, 0x81, 0x81,
      0x00, 0xB1, 0x0B, 0x8F, 0x96, 0xA0, 0x80, 0xE0, 0x1D, 0xDE, 0x92, 0xDE,
      0x5E, 0xAE, 0x5D, 0x54, 0xEC, 0x52, 0xC9, 0x9F, 0xBC, 0xFB, 0x06, 0xA3,
      0xC6, 0x9A, 0x6A, 0x9D, 0xCA, 0x52, 0xD2, 0x3B, 0x61, 0x60, 0x73, 0xE2,
      0x86, 0x75, 0xA2, 0x3D, 0x18, 0x98, 0x38, 0xEF, 0x1E, 0x2E, 0xE6, 0x52,
      0xC0, 0x13, 0xEC, 0xB4, 0xAE, 0xA9, 0x06, 0x11, 0x23, 0x24, 0x97, 0x5C,
      0x3C, 0xD4, 0x9B, 0x83, 0xBF, 0xAC, 0xCB, 0xDD, 0x7D, 0x90, 0xC4, 0xBD,
      0x70, 0x98, 0x48, 0x8E, 0x9C, 0x21, 0x9A, 0x73, 0x72, 0x4E, 0xFF, 0xD6,
      0xFA, 0xE5, 0x64, 0x47, 0x38, 0xFA, 0xA3, 0x1A, 0x4F, 0xF5, 0x5B, 0xCC,
      0xC0, 0xA1, 0x51, 0xAF, 0x5F, 0x0D, 0xC8, 0xB4, 0xBD, 0x45, 0xBF, 0x37,
      0xDF, 0x36, 0x5C, 0x1A, 0x65, 0xE6, 0x8C, 0xFD, 0xA7, 0x6D, 0x4D, 0xA7,
      0x08, 0xDF, 0x1F, 0xB2, 0xBC, 0x2E, 0x4A, 0x43, 0x71, 0x02, 0x81, 0x81,
      0x00, 0xA4, 0xD1, 0xCB, 0xD5, 0xC3, 0xFD, 0x34, 0x12, 0x67, 0x65, 0xA4,
      0x42, 0xEF, 0xB9, 0x99, 0x05, 0xF8, 0x10, 0x4D, 0xD2, 0x58, 0xAC, 0x50,
      0x7F, 0xD6, 0x40, 0x6C, 0xFF, 0x14, 0x26, 0x6D, 0x31, 0x26, 0x6F, 0xEA,
      0x1E, 0x5C, 0x41, 0x56, 0x4B, 0x77, 0x7E, 0x69, 0x0F, 0x55, 0x04, 0xF2,
      0x13, 0x16, 0x02, 0x17, 0xB4, 0xB0, 0x1B, 0x88, 0x6A, 0x5E, 0x91, 0x54,
      0x7F, 0x9E, 0x27, 0x49, 0xF4, 0xD7, 0xFB, 0xD7, 0xD3, 0xB9, 0xA9, 0x2E,
      0xE1, 0x90, 0x9D, 0x0D, 0x22, 0x63, 0xF8, 0x0A, 0x76, 0xA6, 0xA2, 0x4C,
      0x08, 0x7A, 0x09, 0x1F, 0x53, 0x1D, 0xBF, 0x0A, 0x01, 0x69, 0xB6, 0xA2,
      0x8A, 0xD6, 0x62, 0xA4, 0xD1, 0x8E, 0x73, 0xAF, 0xA3, 0x2D, 0x77, 0x9D,
      0x59, 0x18, 0xD0, 0x8B, 0xC8, 0x85, 0x8F, 0x4D, 0xCE, 0xF9, 0x7C, 0x2A,
      0x24, 0x85, 0x5E, 0x6E, 0xEB, 0x22, 0xB3, 0xB2, 0xE5, 0x02, 0x15, 0x00,
      0xF5, 0x18, 0xAA, 0x87, 0x81, 0xA8, 0xDF, 0x27, 0x8A, 0xBA, 0x4E, 0x7D,
      0x64, 0xB7, 0xCB, 0x9D, 0x49, 0x46, 0x23, 0x53, 0x03, 0x81, 0x84, 0x00,
      0x02, 0x81, 0x80, 0x50, 0x75, 0x26, 0x68, 0xD3, 0x98, 0x0F, 0x61, 0xEE,
      0x5F, 0x41, 0x8D, 0xCD, 0xD1, 0x2C, 0x58, 0x82, 0xE0, 0x97, 0xBC, 0xFE,
      0xFD, 0xED, 0xC7, 0xE4, 0xD1, 0x73, 0xC9, 0x8A, 0x5C, 0x1A, 0x22, 0x5E,
      0x26, 0xCD, 0xFD, 0xC6, 0x7B, 0x51, 0x8E, 0xE5, 0x80, 0x60, 0x69, 0xC4,
      0x76, 0xFD, 0x23, 0x72, 0xE0, 0xEF, 0x08, 0x2D, 0x0A, 0x61, 0x79, 0x3C,
      0x07, 0x54, 0x77, 0xCD, 0x1B, 0x28, 0xDB, 0x62, 0x6F, 0x82, 0xA4, 0xD6,
      0x50, 0xB3, 0xCD, 0xBA, 0xC6, 0x75, 0xA6, 0x48, 0xAD, 0x8C, 0xA4, 0x2B,
      0xE6, 0x0B, 0xED, 0x33, 0x15, 0xA6, 0x12, 0xE1, 0x3F, 0x14, 0x6D, 0xA1,
      0xD7, 0x41, 0x85, 0xD1, 0x38, 0xAB, 0x35, 0xF1, 0x41, 0xA4, 0xEA, 0x5F,
      0xB7, 0x1F, 0x7B, 0xCA, 0x40, 0x6B, 0xB0, 0x32, 0xD7, 0x20, 0x61, 0x6A,
      0xF6, 0x2B, 0xE2, 0x47, 0xA9, 0xF4, 0x04, 0x20, 0x48, 0x7C, 0xA2
  };

static unsigned char dh1024_5114_secret[] = {
      0xB0, 0x9F, 0x2C, 0x6F, 0x4A, 0x7E, 0x67, 0xA0, 0x22, 0x22, 0x64, 0x20,
      0x47, 0xEA, 0x2E, 0x81, 0xDF, 0x96, 0x02, 0x92, 0x0A, 0xE1, 0xBD, 0xE6,
      0x0C, 0x18, 0xE7, 0x02, 0x70, 0x24, 0x6F, 0x69, 0xFA, 0xFC, 0x45, 0xAB,
      0xFC, 0x0F, 0x62, 0x98, 0x07, 0xF9, 0x5F, 0x48, 0x71, 0x22, 0x5A, 0x92,
      0xB1, 0x35, 0x04, 0x87, 0xC3, 0x49, 0x11, 0xFA, 0x08, 0x4F, 0xB8, 0xF9,
      0x6D, 0xC8, 0x5B, 0x6E, 0xB1, 0x40, 0x35, 0x82, 0x19, 0xEC, 0xFF, 0xB1,
      0xC0, 0x29, 0x54, 0x19, 0xEB, 0xC5, 0x96, 0xF0, 0x64, 0xE6, 0x6E, 0xFF,
      0xD7, 0x7B, 0xB3, 0xC4, 0x9C, 0x54, 0xBC, 0xE4, 0x98, 0x90, 0x79, 0x23,
      0xA1, 0x2C, 0xB5, 0x1F, 0xA7, 0xB9, 0xB0, 0x09, 0x01, 0xE0, 0x89, 0xC8,
      0xEE, 0x6C, 0x0F, 0x9A, 0xA9, 0xF1, 0x55, 0x51, 0xE3, 0x03, 0x37, 0x92,
      0x14, 0x60, 0x92, 0xA5, 0x0D, 0x50, 0x8B, 0xB1
  };

static unsigned char dh2048_key[] = {
      0x30, 0x82, 0x02, 0x26, 0x02, 0x01, 0x00, 0x30, 0x82, 0x01, 0x17, 0x06,
      0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x03, 0x01, 0x30, 0x82,
      0x01, 0x08, 0x02, 0x82, 0x01, 0x01, 0x00, 0xC3, 0x9B, 0x85, 0x3C, 0x95,
      0x08, 0xC9, 0xA0, 0xBA, 0xB3, 0xE8, 0x07, 0x3D, 0xA1, 0x85, 0xEF, 0xAC,
      0xAE, 0x62, 0x54, 0x0B, 0x86, 0x0E, 0x07, 0x49, 0x26, 0x38, 0x7A, 0x8A,
      0x5D, 0x98, 0xC1, 0x8E, 0x27, 0xE2, 0x8E, 0x22, 0xF2, 0x10, 0x65, 0x79,
      0xE8, 0xEA, 0xD6, 0x99, 0x98, 0xD8, 0x2E, 0x7D, 0x02, 0x46, 0x6F, 0x39,
      0xC2, 0xEA, 0x03, 0xC9, 0xA9, 0x6E, 0x77, 0x57, 0xA8, 0xB7, 0x8F, 0x5C,
      0x3A, 0x2E, 0xC2, 0xE2, 0x84, 0xE9, 0x84, 0x1E, 0x79, 0x7E, 0x65, 0x14,
      0x11, 0xC9, 0x63, 0x70, 0xE8, 0xBE, 0x4D, 0x68, 0xD8, 0x10, 0x70, 0x9B,
      0xE4, 0xA0, 0x77, 0x07, 0x45, 0x94, 0x7A, 0x14, 0x6D, 0xC8, 0x1F, 0x91,
      0xD5, 0x78, 0x85, 0xFF, 0x65, 0x5B, 0xBC, 0x3C, 0x6E, 0xE7, 0xFD, 0x6C,
      0xA2, 0xCA, 0x19, 0x6D, 0x80, 0x0B, 0xF0, 0x8D, 0xC0, 0x2B, 0x81, 0x9B,
      0x6E, 0x1D, 0xF2, 0x67, 0x35, 0xE0, 0x2D, 0x0D, 0xAE, 0xE1, 0xB1, 0xC6,
      0x24, 0x82, 0x26, 0x85, 0xD1, 0x2B, 0xB6, 0x01, 0x83, 0xE7, 0x33, 0xA5,
      0xF1, 0x48, 0x74, 0xC7, 0x01, 0x20, 0x17, 0x4E, 0x56, 0xC7, 0xA2, 0xA2,
      0xAD, 0xB6, 0x28, 0x49, 0xC3, 0x74, 0x9D, 0x5E, 0xB8, 0x8F, 0x7A, 0xC7,
      0x11, 0xA0, 0xCD, 0xFE, 0x54, 0x33, 0x9D, 0x3C, 0x06, 0xBF, 0x2D, 0x67,
      0xCA, 0x69, 0x69, 0x72, 0x9B, 0xD8, 0x24, 0xF0, 0xB0, 0xF8, 0x02, 0x4D,
      0x40, 0xCF, 0xCD, 0xF9, 0xEB, 0xB6, 0x05, 0xB6, 0x5D, 0x4B, 0x14, 0x9B,
      0xDC, 0xC2, 0x9E, 0x74, 0xD7, 0x73, 0x24, 0x0F, 0xA9, 0x36, 0x83, 0x01,
      0xBB, 0x30, 0x6D, 0x33, 0x86, 0x4C, 0x2C, 0xF9, 0x35, 0x4D, 0x6C, 0xB7,
      0xB5, 0xBA, 0x1F, 0x6A, 0xAE, 0x7E, 0xD8, 0xB0, 0xAA, 0x98, 0x50, 0x0E,
      0xC1, 0x48, 0xF2, 0x92, 0x04, 0x8F, 0xD8, 0x3E, 0xEC, 0x25, 0x0B, 0x02,
      0x01, 0x02, 0x04, 0x82, 0x01, 0x04, 0x02, 0x82, 0x01, 0x00, 0x7F, 0x18,
      0x9C, 0xE2, 0xA6, 0x2B, 0x9A, 0x37, 0x4F, 0xD8, 0xEE, 0x20, 0x7D, 0x83,
      0xFA, 0x05, 0xBF, 0x6A, 0x11, 0x65, 0xA7, 0x7C, 0xE1, 0xF8, 0x71, 0xB2,
      0x7E, 0x57, 0xD7, 0xAF, 0xFB, 0xD5, 0x9B, 0xF2, 0x97, 0xB1, 0x25, 0x6D,
      0x68, 0xA3, 0x58, 0xCB, 0xD6, 0x01, 0xF2, 0x83, 0x6F, 0xAB, 0x8D, 0x90,
      0xD6, 0xA4, 0x8B, 0x74, 0xEC, 0x02, 0x92, 0x91, 0x4B, 0x31, 0x1C, 0x0D,
      0x3D, 0x91, 0x8E, 0xAE, 0xE2, 0x3D, 0xB9, 0x20, 0xAE, 0x7B, 0x92, 0xED,
      0x0A, 0x02, 0xF8, 0x05, 0x08, 0x41, 0x6B, 0x17, 0xDF, 0xCE, 0x39, 0x78,
      0x91, 0x46, 0xA4, 0xBD, 0x0F, 0x54, 0x6E, 0xB6, 0x61, 0x1A, 0x79, 0x76,
      0xF9, 0x12, 0x08, 0xA9, 0x02, 0x68, 0xA8, 0x1D, 0x6E, 0x58, 0xCA, 0x80,
      0x4E, 0x56, 0x1D, 0xA7, 0xF1, 0x4D, 0xB1, 0x9E, 0x5B, 0xCF, 0x02, 0xA2,
      0x17, 0x95, 0x2D, 0xB8, 0xAC, 0x5E, 0xEF, 0x3D, 0x03, 0x29, 0xBE, 0x17,
      0xD1, 0x81, 0x20, 0x2F, 0x70, 0xAE, 0x82, 0x0C, 0x7B, 0x41, 0x31, 0x53,
      0x09, 0xAB, 0xD6, 0xE6, 0xDC, 0x22, 0x5F, 0x65, 0x6A, 0x17, 0x7B, 0x69,
      0x52, 0x5F, 0xAE, 0x08, 0x63, 0x03, 0x8F, 0x41, 0xC8, 0x30, 0x92, 0x0B,
      0x9B, 0x53, 0x35, 0xE1, 0x66, 0xAA, 0xCD, 0x65, 0x3F, 0x42, 0xB5, 0xAA,
      0x6D, 0x04, 0x64, 0x41, 0x41, 0x97, 0xA8, 0xA8, 0x66, 0x5E, 0xDB, 0x59,
      0xD7, 0x3E, 0x06, 0x98, 0x3D, 0x50, 0xC0, 0xB3, 0x0F, 0xAA, 0x7D, 0xA7,
      0x90, 0x04, 0xE2, 0x4B, 0x7F, 0x07, 0x38, 0x40, 0xEE, 0xD4, 0x09, 0xC8,
      0xB4, 0x1D, 0x84, 0x9D, 0x74, 0x32, 0x72, 0x00, 0x63, 0x51, 0xF7, 0x6B,
      0x33, 0x8C, 0xA4, 0x5D, 0x30, 0xFA, 0x69, 0x94, 0xED, 0x0A, 0x63, 0xCA,
      0x4E, 0xD0, 0x5E, 0x78, 0x0B, 0x6C, 0x0D, 0x0C, 0xE0, 0xF0, 0xB2, 0x03,
      0x44, 0x08
  };

static unsigned char dh2048_key_pub[] = {
      0x30, 0x82, 0x02, 0x25, 0x30, 0x82, 0x01, 0x17, 0x06, 0x09, 0x2A, 0x86,
      0x48, 0x86, 0xF7, 0x0D, 0x01, 0x03, 0x01, 0x30, 0x82, 0x01, 0x08, 0x02,
      0x82, 0x01, 0x01, 0x00, 0xC3, 0x9B, 0x85, 0x3C, 0x95, 0x08, 0xC9, 0xA0,
      0xBA, 0xB3, 0xE8, 0x07, 0x3D, 0xA1, 0x85, 0xEF, 0xAC, 0xAE, 0x62, 0x54,
      0x0B, 0x86, 0x0E, 0x07, 0x49, 0x26, 0x38, 0x7A, 0x8A, 0x5D, 0x98, 0xC1,
      0x8E, 0x27, 0xE2, 0x8E, 0x22, 0xF2, 0x10, 0x65, 0x79, 0xE8, 0xEA, 0xD6,
      0x99, 0x98, 0xD8, 0x2E, 0x7D, 0x02, 0x46, 0x6F, 0x39, 0xC2, 0xEA, 0x03,
      0xC9, 0xA9, 0x6E, 0x77, 0x57, 0xA8, 0xB7, 0x8F, 0x5C, 0x3A, 0x2E, 0xC2,
      0xE2, 0x84, 0xE9, 0x84, 0x1E, 0x79, 0x7E, 0x65, 0x14, 0x11, 0xC9, 0x63,
      0x70, 0xE8, 0xBE, 0x4D, 0x68, 0xD8, 0x10, 0x70, 0x9B, 0xE4, 0xA0, 0x77,
      0x07, 0x45, 0x94, 0x7A, 0x14, 0x6D, 0xC8, 0x1F, 0x91, 0xD5, 0x78, 0x85,
      0xFF, 0x65, 0x5B, 0xBC, 0x3C, 0x6E, 0xE7, 0xFD, 0x6C, 0xA2, 0xCA, 0x19,
      0x6D, 0x80, 0x0B, 0xF0, 0x8D, 0xC0, 0x2B, 0x81, 0x9B, 0x6E, 0x1D, 0xF2,
      0x67, 0x35, 0xE0, 0x2D, 0x0D, 0xAE, 0xE1, 0xB1, 0xC6, 0x24, 0x82, 0x26,
      0x85, 0xD1, 0x2B, 0xB6, 0x01, 0x83, 0xE7, 0x33, 0xA5, 0xF1, 0x48, 0x74,
      0xC7, 0x01, 0x20, 0x17, 0x4E, 0x56, 0xC7, 0xA2, 0xA2, 0xAD, 0xB6, 0x28,
      0x49, 0xC3, 0x74, 0x9D, 0x5E, 0xB8, 0x8F, 0x7A, 0xC7, 0x11, 0xA0, 0xCD,
      0xFE, 0x54, 0x33, 0x9D, 0x3C, 0x06, 0xBF, 0x2D, 0x67, 0xCA, 0x69, 0x69,
      0x72, 0x9B, 0xD8, 0x24, 0xF0, 0xB0, 0xF8, 0x02, 0x4D, 0x40, 0xCF, 0xCD,
      0xF9, 0xEB, 0xB6, 0x05, 0xB6, 0x5D, 0x4B, 0x14, 0x9B, 0xDC, 0xC2, 0x9E,
      0x74, 0xD7, 0x73, 0x24, 0x0F, 0xA9, 0x36, 0x83, 0x01, 0xBB, 0x30, 0x6D,
      0x33, 0x86, 0x4C, 0x2C, 0xF9, 0x35, 0x4D, 0x6C, 0xB7, 0xB5, 0xBA, 0x1F,
      0x6A, 0xAE, 0x7E, 0xD8, 0xB0, 0xAA, 0x98, 0x50, 0x0E, 0xC1, 0x48, 0xF2,
      0x92, 0x04, 0x8F, 0xD8, 0x3E, 0xEC, 0x25, 0x0B, 0x02, 0x01, 0x02, 0x03,
      0x82, 0x01, 0x06, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0x89, 0xA1, 0x8C,
      0xD8, 0x5F, 0x1C, 0x26, 0x7C, 0x4F, 0x0D, 0xF9, 0xF6, 0xD2, 0x8A, 0xE9,
      0x56, 0x79, 0xC6, 0x44, 0x80, 0x3B, 0x64, 0x06, 0xC7, 0x5C, 0x64, 0x87,
      0xF6, 0xBA, 0x7B, 0x5A, 0x85, 0xD6, 0xA7, 0x53, 0xF2, 0x38, 0xD7, 0x4B,
      0x96, 0x6B, 0xB5, 0x5A, 0xE9, 0xE3, 0xD9, 0xEF, 0xEF, 0x46, 0x8B, 0x61,
      0x88, 0x4C, 0xEB, 0xD1, 0x36, 0x25, 0x54, 0x86, 0xB4, 0x4B, 0x9E, 0xCB,
      0x67, 0xD9, 0xDD, 0x4F, 0x80, 0xB8, 0xD5, 0xFE, 0xB3, 0xCA, 0x6F, 0xCA,
      0x88, 0x50, 0x29, 0x8C, 0xC3, 0xF3, 0xBD, 0xBE, 0xC7, 0x22, 0x63, 0x2D,
      0x6D, 0x3F, 0xBA, 0x32, 0x7C, 0x80, 0x34, 0x3F, 0x1F, 0xE7, 0xF6, 0x36,
      0x34, 0xC8, 0x3C, 0x4C, 0xBE, 0x0B, 0x44, 0x69, 0xD5, 0x95, 0xB8, 0xDD,
      0xAF, 0x40, 0x72, 0xF0, 0x91, 0x58, 0x15, 0x91, 0x65, 0x6C, 0x83, 0x6B,
      0x02, 0x7A, 0x25, 0x20, 0xF5, 0x1B, 0x5E, 0xC1, 0xFF, 0x96, 0x4E, 0xA0,
      0x9D, 0x33, 0x45, 0x25, 0xFC, 0x17, 0x27, 0xDE, 0x51, 0x19, 0xF4, 0xAD,
      0x7A, 0x7C, 0x64, 0xF9, 0x58, 0x6F, 0x5F, 0xCB, 0x97, 0x50, 0xCD, 0x55,
      0xCF, 0x18, 0xAE, 0x4E, 0x6C, 0xB5, 0xF7, 0xDF, 0xAF, 0xAF, 0x45, 0x25,
      0xA8, 0x32, 0x2D, 0xF2, 0x25, 0x65, 0xC1, 0x6A, 0x9F, 0xA5, 0x67, 0x2D,
      0x9F, 0xDB, 0x8E, 0xDC, 0x65, 0x26, 0x80, 0x5B, 0x81, 0x13, 0x5C, 0xAC,
      0x7F, 0x46, 0x20, 0xBD, 0xA1, 0x02, 0xB1, 0x53, 0x55, 0x85, 0xBD, 0xDC,
      0xBA, 0xC6, 0x46, 0x9A, 0xC6, 0xCE, 0xDA, 0xB2, 0xEE, 0x53, 0x68, 0x50,
      0xEB, 0x9C, 0xCE, 0xF7, 0x85, 0xCE, 0x15, 0xEA, 0xD5, 0x80, 0x63, 0x86,
      0xD5, 0x25, 0x0A, 0xFF, 0x49, 0xDF, 0x71, 0x4D, 0xDD, 0x20, 0x68, 0xD9,
      0xF3, 0xFB, 0x16, 0x6C, 0xC0, 0x5E, 0x60, 0xC9, 0x6D, 0xDF, 0x20, 0x2B,
      0x16
  };

static unsigned char dh2048_secret[] = {
      0x92, 0xB4, 0x7C, 0xC0, 0x5E, 0xCC, 0x69, 0xF6, 0x36, 0x53, 0x2F, 0x50,
      0x20, 0x03, 0xDB, 0x29, 0x20, 0x80, 0xF4, 0x92, 0xE4, 0x31, 0xF2, 0x74,
      0x4D, 0xE5, 0x95, 0x30, 0x63, 0x84, 0x18, 0xCC, 0x0B, 0x52, 0xC0, 0x78,
      0x51, 0x34, 0xCB, 0xC1, 0x11, 0xF8, 0x1F, 0xE0, 0x08, 0x89, 0xB7, 0x46,
      0x40, 0xF0, 0x1D, 0xC8, 0x4F, 0x0A, 0x40, 0x38, 0x44, 0x38, 0xB8, 0x0F,
      0xBE, 0x04, 0x2B, 0xD3, 0x48, 0xA9, 0x07, 0xA1, 0x02, 0xA3, 0x93, 0x7B,
      0x81, 0xE7, 0xD0, 0x9D, 0x59, 0x34, 0xBE, 0x8B, 0xEB, 0x71, 0x29, 0xE3,
      0xCC, 0x04, 0xA4, 0xFC, 0x46, 0x31, 0x36, 0x0F, 0xB1, 0xAB, 0x04, 0x69,
      0xCA, 0x09, 0x99, 0x0C, 0xC8, 0x33, 0x2C, 0xCE, 0xB1, 0x76, 0xD1, 0x40,
      0xE5, 0x01, 0x1B, 0x86, 0x05, 0x0F, 0xF3, 0xF7, 0x35, 0x95, 0x96, 0xD8,
      0x1C, 0xE2, 0x35, 0xB0, 0xB3, 0xB8, 0x75, 0xA2, 0xDE, 0xF3, 0xA2, 0x19,
      0xA0, 0xEF, 0x1A, 0x48, 0x32, 0x99, 0x80, 0x54, 0xE2, 0xCF, 0xBC, 0x98,
      0xB6, 0x40, 0x98, 0x23, 0x3D, 0x4F, 0xEB, 0x23, 0x1F, 0x43, 0x00, 0xAA,
      0x37, 0x12, 0x8F, 0xAD, 0x89, 0x03, 0x4B, 0x6B, 0xE6, 0x7D, 0xBD, 0x55,
      0x93, 0x0B, 0x7A, 0xA4, 0xC1, 0xE1, 0x75, 0x4F, 0x4A, 0x55, 0x29, 0x2F,
      0xAA, 0xAA, 0xD9, 0x50, 0x79, 0xF0, 0xE0, 0xCE, 0x4D, 0x9B, 0x9B, 0x15,
      0x0D, 0x31, 0x70, 0x16, 0x47, 0xDE, 0xE1, 0x1A, 0xC0, 0x25, 0xA0, 0xED,
      0x4A, 0x0E, 0x63, 0x66, 0xEC, 0x73, 0xF6, 0x4C, 0x4C, 0x8D, 0xBB, 0x0C,
      0xBB, 0x62, 0x38, 0xE3, 0xBB, 0xCB, 0xC9, 0x7B, 0x04, 0x73, 0xA8, 0x92,
      0x24, 0x6A, 0x3C, 0x88, 0x2E, 0xE7, 0x56, 0x13, 0xE6, 0x10, 0x2C, 0x6A,
      0x10, 0x3F, 0x0F, 0xD3, 0x58, 0x0A, 0x55, 0x4E, 0x7D, 0x3D, 0x4C, 0x39,
      0xF1, 0x94, 0x62, 0x9D
  };

static unsigned char dh2048_5114_key[] = {
      0x30, 0x82, 0x02, 0x5D, 0x02, 0x01, 0x00, 0x30, 0x82, 0x02, 0x36, 0x06,
      0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3E, 0x02, 0x01, 0x30, 0x82, 0x02, 0x29,
      0x02, 0x82, 0x01, 0x01, 0x00, 0xAD, 0x10, 0x7E, 0x1E, 0x91, 0x23, 0xA9,
      0xD0, 0xD6, 0x60, 0xFA, 0xA7, 0x95, 0x59, 0xC5, 0x1F, 0xA2, 0x0D, 0x64,
      0xE5, 0x68, 0x3B, 0x9F, 0xD1, 0xB5, 0x4B, 0x15, 0x97, 0xB6, 0x1D, 0x0A,
      0x75, 0xE6, 0xFA, 0x14, 0x1D, 0xF9, 0x5A, 0x56, 0xDB, 0xAF, 0x9A, 0x3C,
      0x40, 0x7B, 0xA1, 0xDF, 0x15, 0xEB, 0x3D, 0x68, 0x8A, 0x30, 0x9C, 0x18,
      0x0E, 0x1D, 0xE6, 0xB8, 0x5A, 0x12, 0x74, 0xA0, 0xA6, 0x6D, 0x3F, 0x81,
      0x52, 0xAD, 0x6A, 0xC2, 0x12, 0x90, 0x37, 0xC9, 0xED, 0xEF, 0xDA, 0x4D,
      0xF8, 0xD9, 0x1E, 0x8F, 0xEF, 0x55, 0xB7, 0x39, 0x4B, 0x7A, 0xD5, 0xB7,
      0xD0, 0xB6, 0xC1, 0x22, 0x07, 0xC9, 0xF9, 0x8D, 0x11, 0xED, 0x34, 0xDB,
      0xF6, 0xC6, 0xBA, 0x0B, 0x2C, 0x8B, 0xBC, 0x27, 0xBE, 0x6A, 0x00, 0xE0,
      0xA0, 0xB9, 0xC4, 0x97, 0x08, 0xB3, 0xBF, 0x8A, 0x31, 0x70, 0x91, 0x88,
      0x36, 0x81, 0x28, 0x61, 0x30, 0xBC, 0x89, 0x85, 0xDB, 0x16, 0x02, 0xE7,
      0x14, 0x41, 0x5D, 0x93, 0x30, 0x27, 0x82, 0x73, 0xC7, 0xDE, 0x31, 0xEF,
      0xDC, 0x73, 0x10, 0xF7, 0x12, 0x1F, 0xD5, 0xA0, 0x74, 0x15, 0x98, 0x7D,
      0x9A, 0xDC, 0x0A, 0x48, 0x6D, 0xCD, 0xF9, 0x3A, 0xCC, 0x44, 0x32, 0x83,
      0x87, 0x31, 0x5D, 0x75, 0xE1, 0x98, 0xC6, 0x41, 0xA4, 0x80, 0xCD, 0x86,
      0xA1, 0xB9, 0xE5, 0x87, 0xE8, 0xBE, 0x60, 0xE6, 0x9C, 0xC9, 0x28, 0xB2,
      0xB9, 0xC5, 0x21, 0x72, 0xE4, 0x13, 0x04, 0x2E, 0x9B, 0x23, 0xF1, 0x0B,
      0x0E, 0x16, 0xE7, 0x97, 0x63, 0xC9, 0xB5, 0x3D, 0xCF, 0x4B, 0xA8, 0x0A,
      0x29, 0xE3, 0xFB, 0x73, 0xC1, 0x6B, 0x8E, 0x75, 0xB9, 0x7E, 0xF3, 0x63,
      0xE2, 0xFF, 0xA3, 0x1F, 0x71, 0xCF, 0x9D, 0xE5, 0x38, 0x4E, 0x71, 0xB8,
      0x1C, 0x0A, 0xC4, 0xDF, 0xFE, 0x0C, 0x10, 0xE6, 0x4F, 0x02, 0x82, 0x01,
      0x01, 0x00, 0xAC, 0x40, 0x32, 0xEF, 0x4F, 0x2D, 0x9A, 0xE3, 0x9D, 0xF3,
      0x0B, 0x5C, 0x8F, 0xFD, 0xAC, 0x50, 0x6C, 0xDE, 0xBE, 0x7B, 0x89, 0x99,
      0x8C, 0xAF, 0x74, 0x86, 0x6A, 0x08, 0xCF, 0xE4, 0xFF, 0xE3, 0xA6, 0x82,
      0x4A, 0x4E, 0x10, 0xB9, 0xA6, 0xF0, 0xDD, 0x92, 0x1F, 0x01, 0xA7, 0x0C,
      0x4A, 0xFA, 0xAB, 0x73, 0x9D, 0x77, 0x00, 0xC2, 0x9F, 0x52, 0xC5, 0x7D,
      0xB1, 0x7C, 0x62, 0x0A, 0x86, 0x52, 0xBE, 0x5E, 0x90, 0x01, 0xA8, 0xD6,
      0x6A, 0xD7, 0xC1, 0x76, 0x69, 0x10, 0x19, 0x99, 0x02, 0x4A, 0xF4, 0xD0,
      0x27, 0x27, 0x5A, 0xC1, 0x34, 0x8B, 0xB8, 0xA7, 0x62, 0xD0, 0x52, 0x1B,
      0xC9, 0x8A, 0xE2, 0x47, 0x15, 0x04, 0x22, 0xEA, 0x1E, 0xD4, 0x09, 0x93,
      0x9D, 0x54, 0xDA, 0x74, 0x60, 0xCD, 0xB5, 0xF6, 0xC6, 0xB2, 0x50, 0x71,
      0x7C, 0xBE, 0xF1, 0x80, 0xEB, 0x34, 0x11, 0x8E, 0x98, 0xD1, 0x19, 0x52,
      0x9A, 0x45, 0xD6, 0xF8, 0x34, 0x56, 0x6E, 0x30, 0x25, 0xE3, 0x16, 0xA3,
      0x30, 0xEF, 0xBB, 0x77, 0xA8, 0x6F, 0x0C, 0x1A, 0xB1, 0x5B, 0x05, 0x1A,
      0xE3, 0xD4, 0x28, 0xC8, 0xF8, 0xAC, 0xB7, 0x0A, 0x81, 0x37, 0x15, 0x0B,
      0x8E, 0xEB, 0x10, 0xE1, 0x83, 0xED, 0xD1, 0x99, 0x63, 0xDD, 0xD9, 0xE2,
      0x63, 0xE4, 0x77, 0x05, 0x89, 0xEF, 0x6A, 0xA2, 0x1E, 0x7F, 0x5F, 0x2F,
      0xF3, 0x81, 0xB5, 0x39, 0xCC, 0xE3, 0x40, 0x9D, 0x13, 0xCD, 0x56, 0x6A,
      0xFB, 0xB4, 0x8D, 0x6C, 0x01, 0x91, 0x81, 0xE1, 0xBC, 0xFE, 0x94, 0xB3,
      0x02, 0x69, 0xED, 0xFE, 0x72, 0xFE, 0x9B, 0x6A, 0xA4, 0xBD, 0x7B, 0x5A,
      0x0F, 0x1C, 0x71, 0xCF, 0xFF, 0x4C, 0x19, 0xC4, 0x18, 0xE1, 0xF6, 0xEC,
      0x01, 0x79, 0x81, 0xBC, 0x08, 0x7F, 0x2A, 0x70, 0x65, 0xB3, 0x84, 0xB8,
      0x90, 0xD3, 0x19, 0x1F, 0x2B, 0xFA, 0x02, 0x1D, 0x00, 0x80, 0x1C, 0x0D,
      0x34, 0xC5, 0x8D, 0x93, 0xFE, 0x99, 0x71, 0x77, 0x10, 0x1F, 0x80, 0x53,
      0x5A, 0x47, 0x38, 0xCE, 0xBC, 0xBF, 0x38, 0x9A, 0x99, 0xB3, 0x63, 0x71,
      0xEB, 0x04, 0x1E, 0x02, 0x1C, 0x52, 0xBB, 0xFA, 0xE1, 0xC4, 0xFE, 0x30,
      0xEB, 0xB1, 0xE9, 0xA4, 0xC7, 0x8D, 0x8B, 0x01, 0x63, 0x7C, 0xEE, 0x53,
      0xFD, 0xE1, 0xCB, 0x50, 0xDC, 0x19, 0x47, 0xB4, 0xBC
  };

static unsigned char dh2048_5114_key_pub[] = {
      0x30, 0x82, 0x03, 0x43, 0x30, 0x82, 0x02, 0x36, 0x06, 0x07, 0x2A, 0x86,
      0x48, 0xCE, 0x3E, 0x02, 0x01, 0x30, 0x82, 0x02, 0x29, 0x02, 0x82, 0x01,
      0x01, 0x00, 0xAD, 0x10, 0x7E, 0x1E, 0x91, 0x23, 0xA9, 0xD0, 0xD6, 0x60,
      0xFA, 0xA7, 0x95, 0x59, 0xC5, 0x1F, 0xA2, 0x0D, 0x64, 0xE5, 0x68, 0x3B,
      0x9F, 0xD1, 0xB5, 0x4B, 0x15, 0x97, 0xB6, 0x1D, 0x0A, 0x75, 0xE6, 0xFA,
      0x14, 0x1D, 0xF9, 0x5A, 0x56, 0xDB, 0xAF, 0x9A, 0x3C, 0x40, 0x7B, 0xA1,
      0xDF, 0x15, 0xEB, 0x3D, 0x68, 0x8A, 0x30, 0x9C, 0x18, 0x0E, 0x1D, 0xE6,
      0xB8, 0x5A, 0x12, 0x74, 0xA0, 0xA6, 0x6D, 0x3F, 0x81, 0x52, 0xAD, 0x6A,
      0xC2, 0x12, 0x90, 0x37, 0xC9, 0xED, 0xEF, 0xDA, 0x4D, 0xF8, 0xD9, 0x1E,
      0x8F, 0xEF, 0x55, 0xB7, 0x39, 0x4B, 0x7A, 0xD5, 0xB7, 0xD0, 0xB6, 0xC1,
      0x22, 0x07, 0xC9, 0xF9, 0x8D, 0x11, 0xED, 0x34, 0xDB, 0xF6, 0xC6, 0xBA,
      0x0B, 0x2C, 0x8B, 0xBC, 0x27, 0xBE, 0x6A, 0x00, 0xE0, 0xA0, 0xB9, 0xC4,
      0x97, 0x08, 0xB3, 0xBF, 0x8A, 0x31, 0x70, 0x91, 0x88, 0x36, 0x81, 0x28,
      0x61, 0x30, 0xBC, 0x89, 0x85, 0xDB, 0x16, 0x02, 0xE7, 0x14, 0x41, 0x5D,
      0x93, 0x30, 0x27, 0x82, 0x73, 0xC7, 0xDE, 0x31, 0xEF, 0xDC, 0x73, 0x10,
      0xF7, 0x12, 0x1F, 0xD5, 0xA0, 0x74, 0x15, 0x98, 0x7D, 0x9A, 0xDC, 0x0A,
      0x48, 0x6D, 0xCD, 0xF9, 0x3A, 0xCC, 0x44, 0x32, 0x83, 0x87, 0x31, 0x5D,
      0x75, 0xE1, 0x98, 0xC6, 0x41, 0xA4, 0x80, 0xCD, 0x86, 0xA1, 0xB9, 0xE5,
      0x87, 0xE8, 0xBE, 0x60, 0xE6, 0x9C, 0xC9, 0x28, 0xB2, 0xB9, 0xC5, 0x21,
      0x72, 0xE4, 0x13, 0x04, 0x2E, 0x9B, 0x23, 0xF1, 0x0B, 0x0E, 0x16, 0xE7,
      0x97, 0x63, 0xC9, 0xB5, 0x3D, 0xCF, 0x4B, 0xA8, 0x0A, 0x29, 0xE3, 0xFB,
      0x73, 0xC1, 0x6B, 0x8E, 0x75, 0xB9, 0x7E, 0xF3, 0x63, 0xE2, 0xFF, 0xA3,
      0x1F, 0x71, 0xCF, 0x9D, 0xE5, 0x38, 0x4E, 0x71, 0xB8, 0x1C, 0x0A, 0xC4,
      0xDF, 0xFE, 0x0C, 0x10, 0xE6, 0x4F, 0x02, 0x82, 0x01, 0x01, 0x00, 0xAC,
      0x40, 0x32, 0xEF, 0x4F, 0x2D, 0x9A, 0xE3, 0x9D, 0xF3, 0x0B, 0x5C, 0x8F,
      0xFD, 0xAC, 0x50, 0x6C, 0xDE, 0xBE, 0x7B, 0x89, 0x99, 0x8C, 0xAF, 0x74,
      0x86, 0x6A, 0x08, 0xCF, 0xE4, 0xFF, 0xE3, 0xA6, 0x82, 0x4A, 0x4E, 0x10,
      0xB9, 0xA6, 0xF0, 0xDD, 0x92, 0x1F, 0x01, 0xA7, 0x0C, 0x4A, 0xFA, 0xAB,
      0x73, 0x9D, 0x77, 0x00, 0xC2, 0x9F, 0x52, 0xC5, 0x7D, 0xB1, 0x7C, 0x62,
      0x0A, 0x86, 0x52, 0xBE, 0x5E, 0x90, 0x01, 0xA8, 0xD6, 0x6A, 0xD7, 0xC1,
      0x76, 0x69, 0x10, 0x19, 0x99, 0x02, 0x4A, 0xF4, 0xD0, 0x27, 0x27, 0x5A,
      0xC1, 0x34, 0x8B, 0xB8, 0xA7, 0x62, 0xD0, 0x52, 0x1B, 0xC9, 0x8A, 0xE2,
      0x47, 0x15, 0x04, 0x22, 0xEA, 0x1E, 0xD4, 0x09, 0x93, 0x9D, 0x54, 0xDA,
      0x74, 0x60, 0xCD, 0xB5, 0xF6, 0xC6, 0xB2, 0x50, 0x71, 0x7C, 0xBE, 0xF1,
      0x80, 0xEB, 0x34, 0x11, 0x8E, 0x98, 0xD1, 0x19, 0x52, 0x9A, 0x45, 0xD6,
      0xF8, 0x34, 0x56, 0x6E, 0x30, 0x25, 0xE3, 0x16, 0xA3, 0x30, 0xEF, 0xBB,
      0x77, 0xA8, 0x6F, 0x0C, 0x1A, 0xB1, 0x5B, 0x05, 0x1A, 0xE3, 0xD4, 0x28,
      0xC8, 0xF8, 0xAC, 0xB7, 0x0A, 0x81, 0x37, 0x15, 0x0B, 0x8E, 0xEB, 0x10,
      0xE1, 0x83, 0xED, 0xD1, 0x99, 0x63, 0xDD, 0xD9, 0xE2, 0x63, 0xE4, 0x77,
      0x05, 0x89, 0xEF, 0x6A, 0xA2, 0x1E, 0x7F, 0x5F, 0x2F, 0xF3, 0x81, 0xB5,
      0x39, 0xCC, 0xE3, 0x40, 0x9D, 0x13, 0xCD, 0x56, 0x6A, 0xFB, 0xB4, 0x8D,
      0x6C, 0x01, 0x91, 0x81, 0xE1, 0xBC, 0xFE, 0x94, 0xB3, 0x02, 0x69, 0xED,
      0xFE, 0x72, 0xFE, 0x9B, 0x6A, 0xA4, 0xBD, 0x7B, 0x5A, 0x0F, 0x1C, 0x71,
      0xCF, 0xFF, 0x4C, 0x19, 0xC4, 0x18, 0xE1, 0xF6, 0xEC, 0x01, 0x79, 0x81,
      0xBC, 0x08, 0x7F, 0x2A, 0x70, 0x65, 0xB3, 0x84, 0xB8, 0x90, 0xD3, 0x19,
      0x1F, 0x2B, 0xFA, 0x02, 0x1D, 0x00, 0x80, 0x1C, 0x0D, 0x34, 0xC5, 0x8D,
      0x93, 0xFE, 0x99, 0x71, 0x77, 0x10, 0x1F, 0x80, 0x53, 0x5A, 0x47, 0x38,
      0xCE, 0xBC, 0xBF, 0x38, 0x9A, 0x99, 0xB3, 0x63, 0x71, 0xEB, 0x03, 0x82,
      0x01, 0x05, 0x00, 0x02, 0x82, 0x01, 0x00, 0x2B, 0xA2, 0x1E, 0x84, 0xCD,
      0x25, 0x15, 0xAE, 0xC5, 0x12, 0x01, 0x68, 0x43, 0xFD, 0x95, 0xA2, 0xB8,
      0xB0, 0x52, 0x8B, 0x33, 0xE1, 0xC5, 0x81, 0x62, 0x4D, 0x3C, 0xE2, 0x41,
      0xD1, 0xAE, 0xC0, 0xC4, 0x59, 0xF3, 0x2D, 0xB8, 0xCC, 0x00, 0x26, 0x55,
      0xA2, 0xBF, 0x7F, 0xF7, 0x44, 0x9B, 0x8F, 0xF4, 0xFC, 0xF2, 0x01, 0xE7,
      0x59, 0x52, 0x1E, 0xDB, 0x4F, 0x13, 0xBE, 0x7E, 0xCF, 0x81, 0x8A, 0x44,
      0x66, 0x2D, 0x0A, 0x08, 0x29, 0xEA, 0x60, 0x2B, 0x38, 0x02, 0xD5, 0xCB,
      0x1E, 0xDC, 0xDF, 0x4B, 0x01, 0x55, 0xF0, 0xAF, 0x7C, 0x1A, 0x66, 0xDE,
      0xE5, 0x9A, 0x57, 0xCD, 0x5F, 0x7B, 0xA2, 0x67, 0x24, 0x57, 0x32, 0x94,
      0x53, 0x47, 0xFC, 0xAE, 0xDB, 0xE6, 0x7A, 0x1C, 0x64, 0x5C, 0x3D, 0xFA,
      0x38, 0xA5, 0x9C, 0x33, 0x31, 0x7E, 0x2B, 0x4C, 0x94, 0x5C, 0x2D, 0x31,
      0xAC, 0xDE, 0x80, 0xDF, 0xEF, 0x7C, 0xD7, 0xDD, 0x92, 0x96, 0xB6, 0xED,
      0x56, 0xD0, 0x2A, 0x3C, 0xA7, 0x57, 0x4D, 0x2A, 0x08, 0x46, 0x25, 0x61,
      0xDE, 0x3B, 0x17, 0xD7, 0xB3, 0x9B, 0x7C, 0x1A, 0x43, 0x62, 0x9B, 0xAD,
      0x9B, 0x5F, 0xD8, 0xD2, 0x6E, 0x2F, 0xDE, 0x9B, 0x11, 0xE8, 0xBF, 0x92,
      0x2E, 0x81, 0x0E, 0x4E, 0x46, 0xBB, 0xFC, 0x42, 0x47, 0x16, 0xEA, 0x9C,
      0xC1, 0xB9, 0x98, 0x23, 0x57, 0x01, 0x9A, 0x3A, 0x91, 0x8D, 0x79, 0x4F,
      0x3D, 0x74, 0x2E, 0xE9, 0x78, 0x33, 0xCC, 0xFE, 0x9D, 0xF2, 0x77, 0x60,
      0x91, 0xEF, 0x38, 0xCD, 0xB4, 0x93, 0xB1, 0xAA, 0xFA, 0x92, 0x33, 0x75,
      0xF7, 0x24, 0xF0, 0x2C, 0xEB, 0xEF, 0x38, 0x58, 0x22, 0x5D, 0xDC, 0xA7,
      0x35, 0xAE, 0xA6, 0xEC, 0xBC, 0x9A, 0x44, 0x9F, 0xD9, 0xA3, 0x3A, 0xFF,
      0xA4, 0x95, 0xE0, 0x80, 0xAD, 0x86, 0x66, 0x15, 0x26, 0x39, 0x0C
  };

static unsigned char dh2048_5114_secret[] = {
      0x3E, 0x2B, 0xFA, 0x8E, 0x1C, 0xD1, 0x21, 0xBB, 0x17, 0xA4, 0xAC, 0x82,
      0x05, 0xE1, 0xA8, 0xA2, 0x5E, 0x7E, 0xA7, 0x43, 0x28, 0xDB, 0xB9, 0xD3,
      0xFD, 0x5C, 0x5A, 0x7F, 0x26, 0xCB, 0xD6, 0x51, 0x43, 0x87, 0xFB, 0x7A,
      0xE2, 0xBA, 0x2C, 0xF2, 0x3D, 0xB1, 0xDE, 0x00, 0x46, 0x22, 0x6A, 0x44,
      0xBB, 0xD2, 0x7F, 0xB5, 0x0D, 0xAC, 0x3C, 0xEA, 0x02, 0xEC, 0x3A, 0xEA,
      0xCC, 0xF2, 0xFB, 0xAC, 0x7E, 0x43, 0xF7, 0x79, 0xFE, 0xD6, 0x72, 0xD4,
      0x82, 0x7B, 0xC3, 0x48, 0xDD, 0x28, 0xFD, 0x05, 0xCE, 0xD6, 0xA9, 0x5E,
      0x48, 0x8E, 0xB9, 0x31, 0x3A, 0x19, 0xFF, 0x78, 0x5D, 0xEB, 0x97, 0x2A,
      0xBD, 0xFD, 0x0B, 0x31, 0xD1, 0xCD, 0xAA, 0x35, 0x49, 0xEE, 0x3B, 0x0B,
      0xC7, 0x39, 0x91, 0x49, 0x77, 0x6F, 0x99, 0xCA, 0x74, 0xAD, 0xFF, 0x8E,
      0xD4, 0xC3, 0x7F, 0x61, 0x0D, 0xF7, 0xEB, 0x34, 0x52, 0xC9, 0x12, 0x8B,
      0x8F, 0x0C, 0x2F, 0x2C, 0x9F, 0x9D, 0x5F, 0xB1, 0x73, 0x9F, 0xC7, 0xB1,
      0x43, 0x8D, 0x00, 0x9E, 0x17, 0x23, 0x05, 0x36, 0x3F, 0x5E, 0xB6, 0xAD,
      0x2E, 0x58, 0x8F, 0x34, 0x53, 0x80, 0xD2, 0x06, 0x4E, 0x86, 0x75, 0x59,
      0x37, 0x23, 0xDA, 0x3F, 0xBD, 0x62, 0x8F, 0x9E, 0x5C, 0x63, 0xFC, 0xAC,
      0x9F, 0xF7, 0xDD, 0xB2, 0xC1, 0xB8, 0xA1, 0xF9, 0xAC, 0x2B, 0x43, 0xCC,
      0xDE, 0x2D, 0xBD, 0x97, 0xDE, 0x52, 0x73, 0x33, 0x37, 0x03, 0x13, 0xF6,
      0x9D, 0x13, 0x6D, 0x2A, 0x04, 0xF5, 0x98, 0x85, 0x62, 0x1C, 0xA2, 0x0F,
      0x56, 0xA8, 0x18, 0xBF, 0x15, 0x6D, 0x01, 0xE1, 0x1A, 0xC6, 0x33, 0xF5,
      0x4F, 0x8A, 0x02, 0x70, 0x3D, 0x5D, 0x05, 0x86, 0xFB, 0x20, 0x6C, 0xA5,
      0x62, 0xA4, 0x81, 0xCF, 0x4E, 0x03, 0xEA, 0xDE, 0xFA, 0x1A, 0xB6, 0x94,
      0x69, 0x8B, 0x11, 0x9D
  };

static unsigned char dh1024_pg[] = {
      0x30, 0x81, 0x87, 0x02, 0x81, 0x81, 0x00, 0xcb, 0x00, 0x32, 0x75, 0x58,
      0xf1, 0xd4, 0x4b, 0xe8, 0xf6, 0x27, 0x47, 0x69, 0xdc, 0x63, 0xe6, 0x1f,
      0xc9, 0xe7, 0xb6, 0xbd, 0x1e, 0xaf, 0xed, 0xfe, 0xd8, 0x43, 0x34, 0xa8,
      0x4a, 0x6a, 0xb8, 0x16, 0x1c, 0x22, 0xc4, 0x95, 0x80, 0x21, 0x63, 0x0e,
      0xac, 0xff, 0x26, 0x84, 0xd6, 0x28, 0x53, 0x2f, 0xf2, 0x2b, 0xab, 0x98,
      0x3a, 0x97, 0xdc, 0xe5, 0x0a, 0x56, 0xc0, 0x36, 0x4f, 0x67, 0xc0, 0x86,
      0x6a, 0x70, 0x70, 0x21, 0x89, 0x88, 0xad, 0xef, 0xaa, 0x00, 0x3b, 0x57,
      0x52, 0x7e, 0xcf, 0x59, 0x42, 0x87, 0x04, 0x62, 0x4a, 0x33, 0xe0, 0xda,
      0xf3, 0xcc, 0x3d, 0x6b, 0xe7, 0xd4, 0xc6, 0xc3, 0xa8, 0xd8, 0xd1, 0x9b,
      0x1a, 0xb7, 0xa3, 0x7f, 0x48, 0xf3, 0x03, 0xcc, 0x7c, 0x78, 0xb0, 0x2c,
      0x6a, 0xa2, 0x97, 0x7c, 0xf1, 0xee, 0x7d, 0x10, 0x24, 0x56, 0xbd, 0x87,
      0x69, 0xf5, 0x0b, 0x02, 0x01, 0x02
  };

static unsigned char dh1024_5114_pg[] = {
      0x30, 0x82, 0x01, 0x08, 0x02, 0x81, 0x81, 0x00, 0xb1, 0x0b, 0x8f, 0x96,
      0xa0, 0x80, 0xe0, 0x1d, 0xde, 0x92, 0xde, 0x5e, 0xae, 0x5d, 0x54, 0xec,
      0x52, 0xc9, 0x9f, 0xbc, 0xfb, 0x06, 0xa3, 0xc6, 0x9a, 0x6a, 0x9d, 0xca,
      0x52, 0xd2, 0x3b, 0x61, 0x60, 0x73, 0xe2, 0x86, 0x75, 0xa2, 0x3d, 0x18,
      0x98, 0x38, 0xef, 0x1e, 0x2e, 0xe6, 0x52, 0xc0, 0x13, 0xec, 0xb4, 0xae,
      0xa9, 0x06, 0x11, 0x23, 0x24, 0x97, 0x5c, 0x3c, 0xd4, 0x9b, 0x83, 0xbf,
      0xac, 0xcb, 0xdd, 0x7d, 0x90, 0xc4, 0xbd, 0x70, 0x98, 0x48, 0x8e, 0x9c,
      0x21, 0x9a, 0x73, 0x72, 0x4e, 0xff, 0xd6, 0xfa, 0xe5, 0x64, 0x47, 0x38,
      0xfa, 0xa3, 0x1a, 0x4f, 0xf5, 0x5b, 0xcc, 0xc0, 0xa1, 0x51, 0xaf, 0x5f,
      0x0d, 0xc8, 0xb4, 0xbd, 0x45, 0xbf, 0x37, 0xdf, 0x36, 0x5c, 0x1a, 0x65,
      0xe6, 0x8c, 0xfd, 0xa7, 0x6d, 0x4d, 0xa7, 0x08, 0xdf, 0x1f, 0xb2, 0xbc,
      0x2e, 0x4a, 0x43, 0x71, 0x02, 0x81, 0x81, 0x00, 0xa4, 0xd1, 0xcb, 0xd5,
      0xc3, 0xfd, 0x34, 0x12, 0x67, 0x65, 0xa4, 0x42, 0xef, 0xb9, 0x99, 0x05,
      0xf8, 0x10, 0x4d, 0xd2, 0x58, 0xac, 0x50, 0x7f, 0xd6, 0x40, 0x6c, 0xff,
      0x14, 0x26, 0x6d, 0x31, 0x26, 0x6f, 0xea, 0x1e, 0x5c, 0x41, 0x56, 0x4b,
      0x77, 0x7e, 0x69, 0x0f, 0x55, 0x04, 0xf2, 0x13, 0x16, 0x02, 0x17, 0xb4,
      0xb0, 0x1b, 0x88, 0x6a, 0x5e, 0x91, 0x54, 0x7f, 0x9e, 0x27, 0x49, 0xf4,
      0xd7, 0xfb, 0xd7, 0xd3, 0xb9, 0xa9, 0x2e, 0xe1, 0x90, 0x9d, 0x0d, 0x22,
      0x63, 0xf8, 0x0a, 0x76, 0xa6, 0xa2, 0x4c, 0x08, 0x7a, 0x09, 0x1f, 0x53,
      0x1d, 0xbf, 0x0a, 0x01, 0x69, 0xb6, 0xa2, 0x8a, 0xd6, 0x62, 0xa4, 0xd1,
      0x8e, 0x73, 0xaf, 0xa3, 0x2d, 0x77, 0x9d, 0x59, 0x18, 0xd0, 0x8b, 0xc8,
      0x85, 0x8f, 0x4d, 0xce, 0xf9, 0x7c, 0x2a, 0x24, 0x85, 0x5e, 0x6e, 0xeb,
      0x22, 0xb3, 0xb2, 0xe5
  };

static unsigned char dh2048_pg[] = {
      0x30, 0x82, 0x01, 0x08, 0x02, 0x82, 0x01, 0x01, 0x00, 0xbc, 0xbd, 0x96,
      0x00, 0xae, 0x1f, 0x0f, 0xcf, 0x6a, 0x05, 0x72, 0xe6, 0x1b, 0x92, 0xe7,
      0x32, 0xab, 0x5c, 0x08, 0xae, 0x43, 0xde, 0x7f, 0xb4, 0xdb, 0xb2, 0x34,
      0x54, 0xf4, 0x76, 0xea, 0xbe, 0x95, 0x80, 0x1b, 0x29, 0x50, 0xa9, 0x25,
      0x5a, 0xfb, 0xc0, 0x26, 0xe4, 0xae, 0x17, 0x66, 0xd2, 0x52, 0xca, 0x38,
      0x6f, 0x5e, 0x2e, 0xf9, 0xb2, 0x77, 0x60, 0x57, 0xae, 0x7b, 0x43, 0x53,
      0xf1, 0x7a, 0x2d, 0xae, 0x58, 0xd9, 0x24, 0xca, 0xc3, 0xb4, 0xf4, 0xdb,
      0x1c, 0xea, 0x2e, 0x5f, 0x9a, 0x61, 0xc8, 0xab, 0xb2, 0x89, 0xb7, 0xce,
      0x57, 0x0d, 0xe0, 0x3b, 0x80, 0xd4, 0xbb, 0x81, 0x3a, 0x7b, 0x4a, 0x0e,
      0x6f, 0x9c, 0xa9, 0x89, 0xa2, 0xcd, 0x7f, 0x78, 0x36, 0x69, 0x9b, 0xb1,
      0xc7, 0x21, 0xd5, 0x9a, 0xd8, 0x76, 0xd3, 0xe6, 0xdb, 0xf6, 0x0e, 0x65,
      0x98, 0x76, 0x66, 0xba, 0x5a, 0x6b, 0x22, 0x51, 0x49, 0xa1, 0xf8, 0xb3,
      0x71, 0x92, 0xb4, 0xc5, 0x68, 0x0c, 0x50, 0xba, 0xe6, 0xb7, 0x24, 0xc0,
      0xbb, 0x0e, 0x19, 0x94, 0x67, 0x3d, 0x3d, 0xa3, 0xc3, 0x6f, 0x91, 0xa2,
      0xb7, 0x75, 0x41, 0x07, 0x21, 0x54, 0xc1, 0xa7, 0x14, 0xda, 0xae, 0xc6,
      0xaa, 0xa2, 0xfb, 0xff, 0x89, 0xfb, 0xf5, 0xce, 0x60, 0xa4, 0xe4, 0x58,
      0x70, 0x0b, 0xe3, 0xa7, 0x24, 0xc4, 0xb2, 0xbd, 0xdc, 0x94, 0x5d, 0x98,
      0x55, 0xa2, 0x3c, 0xc3, 0x6f, 0x69, 0xae, 0x78, 0xfc, 0xe7, 0xa5, 0x55,
      0x52, 0x3a, 0x87, 0xe8, 0xd6, 0x87, 0xc6, 0xe2, 0x1e, 0x10, 0xa8, 0xcf,
      0xd6, 0x26, 0x5b, 0x35, 0x0f, 0x7f, 0x51, 0x26, 0x32, 0x80, 0x48, 0x68,
      0xb9, 0xa5, 0xe1, 0x61, 0x07, 0xb9, 0xc1, 0x43, 0xaf, 0x57, 0xa3, 0x3e,
      0x52, 0xfe, 0xef, 0xab, 0x8e, 0x34, 0xdc, 0x39, 0xa5, 0x01, 0xb3, 0x30,
      0x53, 0x02, 0x01, 0x02
  };

static unsigned char dh2048_5114_pg[] = {
      0x30, 0x82, 0x02, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xad, 0x10, 0x7e,
      0x1e, 0x91, 0x23, 0xa9, 0xd0, 0xd6, 0x60, 0xfa, 0xa7, 0x95, 0x59, 0xc5,
      0x1f, 0xa2, 0x0d, 0x64, 0xe5, 0x68, 0x3b, 0x9f, 0xd1, 0xb5, 0x4b, 0x15,
      0x97, 0xb6, 0x1d, 0x0a, 0x75, 0xe6, 0xfa, 0x14, 0x1d, 0xf9, 0x5a, 0x56,
      0xdb, 0xaf, 0x9a, 0x3c, 0x40, 0x7b, 0xa1, 0xdf, 0x15, 0xeb, 0x3d, 0x68,
      0x8a, 0x30, 0x9c, 0x18, 0x0e, 0x1d, 0xe6, 0xb8, 0x5a, 0x12, 0x74, 0xa0,
      0xa6, 0x6d, 0x3f, 0x81, 0x52, 0xad, 0x6a, 0xc2, 0x12, 0x90, 0x37, 0xc9,
      0xed, 0xef, 0xda, 0x4d, 0xf8, 0xd9, 0x1e, 0x8f, 0xef, 0x55, 0xb7, 0x39,
      0x4b, 0x7a, 0xd5, 0xb7, 0xd0, 0xb6, 0xc1, 0x22, 0x07, 0xc9, 0xf9, 0x8d,
      0x11, 0xed, 0x34, 0xdb, 0xf6, 0xc6, 0xba, 0x0b, 0x2c, 0x8b, 0xbc, 0x27,
      0xbe, 0x6a, 0x00, 0xe0, 0xa0, 0xb9, 0xc4, 0x97, 0x08, 0xb3, 0xbf, 0x8a,
      0x31, 0x70, 0x91, 0x88, 0x36, 0x81, 0x28, 0x61, 0x30, 0xbc, 0x89, 0x85,
      0xdb, 0x16, 0x02, 0xe7, 0x14, 0x41, 0x5d, 0x93, 0x30, 0x27, 0x82, 0x73,
      0xc7, 0xde, 0x31, 0xef, 0xdc, 0x73, 0x10, 0xf7, 0x12, 0x1f, 0xd5, 0xa0,
      0x74, 0x15, 0x98, 0x7d, 0x9a, 0xdc, 0x0a, 0x48, 0x6d, 0xcd, 0xf9, 0x3a,
      0xcc, 0x44, 0x32, 0x83, 0x87, 0x31, 0x5d, 0x75, 0xe1, 0x98, 0xc6, 0x41,
      0xa4, 0x80, 0xcd, 0x86, 0xa1, 0xb9, 0xe5, 0x87, 0xe8, 0xbe, 0x60, 0xe6,
      0x9c, 0xc9, 0x28, 0xb2, 0xb9, 0xc5, 0x21, 0x72, 0xe4, 0x13, 0x04, 0x2e,
      0x9b, 0x23, 0xf1, 0x0b, 0x0e, 0x16, 0xe7, 0x97, 0x63, 0xc9, 0xb5, 0x3d,
      0xcf, 0x4b, 0xa8, 0x0a, 0x29, 0xe3, 0xfb, 0x73, 0xc1, 0x6b, 0x8e, 0x75,
      0xb9, 0x7e, 0xf3, 0x63, 0xe2, 0xff, 0xa3, 0x1f, 0x71, 0xcf, 0x9d, 0xe5,
      0x38, 0x4e, 0x71, 0xb8, 0x1c, 0x0a, 0xc4, 0xdf, 0xfe, 0x0c, 0x10, 0xe6,
      0x4f, 0x02, 0x82, 0x01, 0x01, 0x00, 0xac, 0x40, 0x32, 0xef, 0x4f, 0x2d,
      0x9a, 0xe3, 0x9d, 0xf3, 0x0b, 0x5c, 0x8f, 0xfd, 0xac, 0x50, 0x6c, 0xde,
      0xbe, 0x7b, 0x89, 0x99, 0x8c, 0xaf, 0x74, 0x86, 0x6a, 0x08, 0xcf, 0xe4,
      0xff, 0xe3, 0xa6, 0x82, 0x4a, 0x4e, 0x10, 0xb9, 0xa6, 0xf0, 0xdd, 0x92,
      0x1f, 0x01, 0xa7, 0x0c, 0x4a, 0xfa, 0xab, 0x73, 0x9d, 0x77, 0x00, 0xc2,
      0x9f, 0x52, 0xc5, 0x7d, 0xb1, 0x7c, 0x62, 0x0a, 0x86, 0x52, 0xbe, 0x5e,
      0x90, 0x01, 0xa8, 0xd6, 0x6a, 0xd7, 0xc1, 0x76, 0x69, 0x10, 0x19, 0x99,
      0x02, 0x4a, 0xf4, 0xd0, 0x27, 0x27, 0x5a, 0xc1, 0x34, 0x8b, 0xb8, 0xa7,
      0x62, 0xd0, 0x52, 0x1b, 0xc9, 0x8a, 0xe2, 0x47, 0x15, 0x04, 0x22, 0xea,
      0x1e, 0xd4, 0x09, 0x93, 0x9d, 0x54, 0xda, 0x74, 0x60, 0xcd, 0xb5, 0xf6,
      0xc6, 0xb2, 0x50, 0x71, 0x7c, 0xbe, 0xf1, 0x80, 0xeb, 0x34, 0x11, 0x8e,
      0x98, 0xd1, 0x19, 0x52, 0x9a, 0x45, 0xd6, 0xf8, 0x34, 0x56, 0x6e, 0x30,
      0x25, 0xe3, 0x16, 0xa3, 0x30, 0xef, 0xbb, 0x77, 0xa8, 0x6f, 0x0c, 0x1a,
      0xb1, 0x5b, 0x05, 0x1a, 0xe3, 0xd4, 0x28, 0xc8, 0xf8, 0xac, 0xb7, 0x0a,
      0x81, 0x37, 0x15, 0x0b, 0x8e, 0xeb, 0x10, 0xe1, 0x83, 0xed, 0xd1, 0x99,
      0x63, 0xdd, 0xd9, 0xe2, 0x63, 0xe4, 0x77, 0x05, 0x89, 0xef, 0x6a, 0xa2,
      0x1e, 0x7f, 0x5f, 0x2f, 0xf3, 0x81, 0xb5, 0x39, 0xcc, 0xe3, 0x40, 0x9d,
      0x13, 0xcd, 0x56, 0x6a, 0xfb, 0xb4, 0x8d, 0x6c, 0x01, 0x91, 0x81, 0xe1,
      0xbc, 0xfe, 0x94, 0xb3, 0x02, 0x69, 0xed, 0xfe, 0x72, 0xfe, 0x9b, 0x6a,
      0xa4, 0xbd, 0x7b, 0x5a, 0x0f, 0x1c, 0x71, 0xcf, 0xff, 0x4c, 0x19, 0xc4,
      0x18, 0xe1, 0xf6, 0xec, 0x01, 0x79, 0x81, 0xbc, 0x08, 0x7f, 0x2a, 0x70,
      0x65, 0xb3, 0x84, 0xb8, 0x90, 0xd3, 0x19, 0x1f, 0x2b, 0xfa
  };

struct pthread_arg {
  int argc;
  char **argv;
};

#define see_selfprintf printf

enum CertFormat {
  CERT_FORMAT_DER,
  CERT_FORMAT_PEM
};

static void print_buffer(char *title, unsigned char *buffer, unsigned int len) {
  unsigned int i = 0;

  printf("%s :", title);
  for (i = 0; i < len; i++) {
    if (i % 4 == 0)
      printf(" ");
    if (i % 16 == 0)
      printf("\n");
    printf("%02X", buffer[i]);
  }
  printf("\n\n");
}

static int security_get_certificates(artik::Security *security) {
  int test_result = 0;
  artik_error ret = S_OK;
  unsigned int i, cnt = 0;
  unsigned char *cert = NULL;
  unsigned int certlen = 0;
  char key_name[20] = {0};
  char der_cert[10];
  char *test_cert_pem;

  unsigned char test_cert_der[] = {
      0x30, 0x82, 0x02, 0x22, 0x30, 0x82, 0x01, 0xC8, 0xA0, 0x03, 0x02, 0x01,
      0x02, 0x02, 0x09, 0x00, 0xB7, 0x5A, 0x90, 0xE7, 0x75, 0x1A, 0xD9, 0x37,
      0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02,
      0x30, 0x64, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
      0x02, 0x55, 0x53, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08,
      0x0C, 0x02, 0x55, 0x53, 0x31, 0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04,
      0x07, 0x0C, 0x04, 0x54, 0x65, 0x73, 0x74, 0x31, 0x0D, 0x30, 0x0B, 0x06,
      0x03, 0x55, 0x04, 0x0A, 0x0C, 0x04, 0x54, 0x65, 0x73, 0x74, 0x31, 0x0D,
      0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x54, 0x65, 0x73,
      0x74, 0x31, 0x1B, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x12,
      0x4B, 0x79, 0x72, 0x69, 0x6F, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x52,
      0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x37,
      0x30, 0x31, 0x31, 0x36, 0x30, 0x38, 0x31, 0x35, 0x30, 0x34, 0x5A, 0x17,
      0x0D, 0x33, 0x37, 0x30, 0x31, 0x31, 0x31, 0x30, 0x38, 0x31, 0x35, 0x30,
      0x34, 0x5A, 0x30, 0x64, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
      0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55,
      0x04, 0x08, 0x0C, 0x02, 0x55, 0x53, 0x31, 0x0D, 0x30, 0x0B, 0x06, 0x03,
      0x55, 0x04, 0x07, 0x0C, 0x04, 0x54, 0x65, 0x73, 0x74, 0x31, 0x0D, 0x30,
      0x0B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x04, 0x54, 0x65, 0x73, 0x74,
      0x31, 0x0D, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x0C, 0x04, 0x54,
      0x65, 0x73, 0x74, 0x31, 0x1B, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03,
      0x0C, 0x12, 0x4B, 0x79, 0x72, 0x69, 0x6F, 0x20, 0x54, 0x65, 0x73, 0x74,
      0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x59, 0x30, 0x13,
      0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A,
      0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xBD,
      0x79, 0xE8, 0x95, 0xC4, 0x02, 0x08, 0xB2, 0xD1, 0xE9, 0x22, 0x71, 0x21,
      0x6C, 0x88, 0x4D, 0x18, 0xDB, 0x6A, 0xBD, 0x9D, 0xD0, 0xAF, 0x58, 0x75,
      0x35, 0x76, 0xEF, 0x25, 0xE0, 0xB7, 0x06, 0x00, 0x98, 0xE4, 0xB5, 0x21,
      0x3A, 0x98, 0x70, 0x6F, 0x7D, 0x8F, 0x8E, 0x08, 0xEF, 0x1E, 0x8F, 0xA6,
      0xD0, 0x14, 0x5B, 0x75, 0xFE, 0x55, 0x86, 0xAF, 0x6B, 0x32, 0xDA, 0x4F,
      0xF5, 0x49, 0x38, 0xA3, 0x63, 0x30, 0x61, 0x30, 0x1D, 0x06, 0x03, 0x55,
      0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x07, 0xD4, 0x5E, 0x12, 0xBC, 0xB8,
      0xEC, 0xC0, 0xC1, 0xE9, 0x09, 0x7E, 0x37, 0xB4, 0xC9, 0x7F, 0xF2, 0x71,
      0x1A, 0x10, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30,
      0x16, 0x80, 0x14, 0x07, 0xD4, 0x5E, 0x12, 0xBC, 0xB8, 0xEC, 0xC0, 0xC1,
      0xE9, 0x09, 0x7E, 0x37, 0xB4, 0xC9, 0x7F, 0xF2, 0x71, 0x1A, 0x10, 0x30,
      0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30,
      0x03, 0x01, 0x01, 0xFF, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01,
      0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x0A, 0x06, 0x08,
      0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x03, 0x48, 0x00, 0x30,
      0x45, 0x02, 0x21, 0x00, 0x89, 0x5F, 0xCC, 0xF1, 0x6A, 0xAC, 0xBF, 0x06,
      0x63, 0x74, 0xA4, 0xA4, 0x19, 0x3B, 0x91, 0x75, 0xB2, 0x58, 0xEB, 0xDC,
      0x73, 0x0C, 0x48, 0x13, 0x7D, 0x92, 0xCB, 0xE1, 0x80, 0x29, 0x05, 0x9E,
      0x02, 0x20, 0x74, 0x94, 0xE2, 0x97, 0xAF, 0x43, 0x43, 0x15, 0x3B, 0x5B,
      0x1B, 0xBE, 0x24, 0x5D, 0x83, 0x78, 0xA7, 0x61, 0x7D, 0xE9, 0x58, 0xED,
      0xBB, 0x9C, 0xD9, 0x35, 0x82, 0xFF, 0x26, 0x3B, 0xD1, 0xC3
  };
  unsigned char test_name[][32] = {
      "ARTIK Device Certificate",
      "ARTIK Device CA Certificate",
      "ARTIK Root CA Certificate"
  };

  /*
   * Get ARTIK certificates
   */
  for (i = 0 ; i < ARTIK_CERTS_NUM ; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", ARTIK_STORAGE, i);

    ret = security->get_certificate(key_name,
        ARTIK_SECURITY_CERT_TYPE_PEM, reinterpret_cast<unsigned char**>(&cert),
        reinterpret_cast<unsigned int*>(&certlen));
    if ((ret != S_OK) || !cert) {
      fprintf(stderr, "Failed to get certificate (err=%d)\n", ret);
      test_result++;
      goto exit;
    }

    see_selfprintf("[%d] %s ", cnt++, test_name[i]);
    see_selfprintf(" success\n");

    if (cert) {
      free(cert);
      cert = NULL;
    }
    certlen = 0;
  }

  test_cert_pem = reinterpret_cast<char*>(malloc(strlen(TEST_CERT_PEM) + 1));
  memcpy(test_cert_pem, TEST_CERT_PEM, strlen(TEST_CERT_PEM) + 1);
  /*
   * Inject PEM certificate and get it in DER form.
   */
  memset(key_name, 0, sizeof(key_name));
  snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, 0);
  ret = security->set_certificate(key_name,
      reinterpret_cast<unsigned char*>(test_cert_pem), strlen(test_cert_pem));
  ret += security->get_certificate(key_name,
      ARTIK_SECURITY_CERT_TYPE_DER, reinterpret_cast<unsigned char**>(&cert),
      reinterpret_cast<unsigned int*>(&certlen));
  ret += security->remove_certificate(key_name);
  free(test_cert_pem);
  if ((ret != S_OK) || !cert) {
    fprintf(stderr, "Failed to get certificate (err=%d)\n", ret);
    test_result++;
    goto exit;
  }

  memcpy(der_cert, "DER_CERT", 9);
  if (cert)
    print_buffer(der_cert, cert, certlen);

  see_selfprintf("[%d] ", cnt++);

  if (!cert || ret) {
    test_result++;
    see_selfprintf(" fail\n");
  } else if (cert[0] != 0x30 || cert[1] != 0x82) {
    test_result++;
    see_selfprintf(" fail\n");
  } else {
    see_selfprintf(" success\n");
  }

  if (cert) {
    free(cert);
    cert = NULL;
  }
  certlen = 0;

  /*
   * Inject DER certificate and get it in PEM form.
   */
  memset(key_name, 0, sizeof(key_name));
  snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, 1);
  ret = security->set_certificate(key_name,
      test_cert_der, sizeof(test_cert_der));
  ret += security->get_certificate(key_name,
      ARTIK_SECURITY_CERT_TYPE_PEM, reinterpret_cast<unsigned char**>(&cert),
      reinterpret_cast<unsigned int*>(&certlen));
  ret += security->remove_certificate(key_name);
  if ((ret != S_OK) || !cert) {
    fprintf(stderr, "Failed to get certificate (err=%d)\n", ret);
    test_result++;
    goto exit;
  }

  if (cert)
    printf("PEM_CERT :\n%s\n", cert);

  see_selfprintf("[%d] ", cnt++);

  if (!cert || ret) {
    test_result++;
    see_selfprintf(" fail\n");
  } else if (!strstr(reinterpret_cast<const char*>(cert), PEM_BEGIN_CRT)) {
    test_result++;
    see_selfprintf(" fail\n");
  } else {
    see_selfprintf(" success\n");
  }

  if (cert) {
    free(cert);
    cert = NULL;
  }
  certlen = 0;

exit:
  if (cert)
    free(cert);

  return test_result;
}

static int security_rand(artik::Security *security) {
  int test_result = 0;
  artik_error err = S_OK;
  unsigned char *rand_bytes = NULL;
  int num_bytes = 32;
  int i = 0;

  fprintf(stderr, "--------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : get random number\n");
  fprintf(stderr, "--------------------------------------------\n");

  err = security->get_random_bytes(num_bytes, &rand_bytes);
  if (err != S_OK || !rand_bytes) {
    fprintf(stderr, "Failed to get random bytes (err=%d)\n", err);
    test_result++;
    goto exit;
  }

  for (i = 0; i < num_bytes; i++)
    fprintf(stdout, "%02x ", rand_bytes[i]);

  fprintf(stdout, "\n");

exit:
  if (rand_bytes)
    free(rand_bytes);

  return test_result;
}

static int security_rsa_encrypt_decrypt(artik::Security *security) {
  int ret = 0;
  int test_result = 0;
  unsigned char input[128];
  char key_name[20] = { 0 };
  unsigned char *out = NULL;
  unsigned char *check = NULL;
  unsigned int inlen, outlen = 0, checklen = 0;
  unsigned int i, cnt = 0;

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : rsa encrypt/decrypt\n");
  fprintf(stderr, "------------------------------------------------------\n");

  inlen = sizeof(input);

  for (i = 0; i < 9; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    memset(input, i + 1, inlen);

    ret = security->set_key(RSA_1024, key_name, rsa1024_sample,
                            sizeof(rsa1024_sample));
    ret += security->rsa_encryption(RSAES_1024_PKCS1_V1_5,
      key_name, input, inlen, &out, &outlen);
    ret += security->rsa_decryption(RSAES_1024_PKCS1_V1_5,
      key_name, out, outlen, &check, &checklen);
    ret += security->remove_key(RSA_1024, key_name);

    if (!check) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf("[%d] ", cnt++);

      if (i == 8 && ret) {
        see_selfprintf(" success\n");
      } else if (ret || memcmp(input, check, checklen)) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (out) {
        free(out);
        out = NULL;
      }
      if (check) {
        free(check);
        check = NULL;
      }
    }
  }

  for (i = 0; i < 5; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_MEMORY, i);

    memset(input, i + 1, inlen);

    ret = security->set_key(RSA_1024, key_name, rsa1024_sample,
                            sizeof(rsa1024_sample));
    ret += security->rsa_encryption(RSAES_1024_PKCS1_V1_5,
      key_name, input, inlen, &out, &outlen);
    ret += security->rsa_decryption(RSAES_1024_PKCS1_V1_5,
      key_name, out, outlen, &check, &checklen);
    ret += security->remove_key(RSA_1024, key_name);

    if (!check) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf("[%d] ", cnt++);

      if (cnt >= i && ret) {
        see_selfprintf(" success\n");
      } else if (ret || memcmp(input, check, checklen)) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (out) {
        free(out);
        out = NULL;
      }

      free(check);
      check = NULL;
    }
  }

  for (i = 0; i < 9; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    memset(input, i + 1, inlen);

    ret = security->set_key(RSA_2048, key_name, rsa2048_sample,
                            sizeof(rsa2048_sample));
    ret += security->rsa_encryption(RSAES_2048_PKCS1_V1_5,
      key_name, input, inlen, &out, &outlen);
    ret += security->rsa_decryption(RSAES_2048_PKCS1_V1_5,
      key_name, out, outlen, &check, &checklen);
    ret += security->remove_key(RSA_2048, key_name);

    if (!check) {
        test_result++;
        see_selfprintf(" fail\n");
    } else {
      see_selfprintf("[%d] ", cnt++);

      if (i == 8 && ret) {
        see_selfprintf(" success\n");
      } else if (ret || memcmp(input, check, checklen)) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (out) {
        free(out);
        out = NULL;
      }

      free(check);
      check = NULL;
    }
  }

  for (i = 0; i < 5; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_MEMORY, i);

    memset(input, i + 1, inlen);

    ret = security->set_key(RSA_2048, key_name, rsa2048_sample,
                            sizeof(rsa2048_sample));
    ret += security->rsa_encryption(RSAES_2048_PKCS1_V1_5,
      key_name, input, inlen, &out, &outlen);
    ret += security->rsa_decryption(RSAES_2048_PKCS1_V1_5,
      key_name, out, outlen, &check, &checklen);
    ret += security->remove_key(RSA_2048, key_name);

    if (!check) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf("[%d] ", cnt++);

      if (i >= 4 && ret) {
        see_selfprintf(" success\n");
      } else if (ret || memcmp(input, check, checklen)) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }
      if (out) {
        free(out);
        out = NULL;
      }

      free(check);
      check = NULL;
    }
  }

  if (out) {
    free(out);
    out = NULL;
  }
  if (check) {
    free(check);
    check = NULL;
  }

  return test_result;
}

static int security_aes_encrypt_decrypt(artik::Security *security) {
  int test_result = 0;
  artik_error ret = S_OK;
  unsigned int i, j;
  unsigned int aes_info[3][2] = { {AES_128, 16}, {AES_192, 24}, {AES_256, 32} };
  unsigned int aes_mode[][2] = { {AES_ECB_NOPAD, 32}, {AES_ECB_PKCS7, 13},
    {AES_CBC_NOPAD, 32}, {AES_CBC_PKCS7, 13}, {AES_CTR_NOPAD, 32}
  };
  unsigned char aes_input[150] = {
    1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
    6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,
    1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
    6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,
    1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
    6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
  };
  unsigned char iv[8] = { 0 };
  char key_name[16] = { 0 };
  unsigned char *out = NULL;
  unsigned int outlen = 0;
  unsigned char *check = NULL;
  unsigned int checklen = 0;
  unsigned int cnt = 0;

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : aes encrypt/decrypt\n");
  fprintf(stderr, "------------------------------------------------------\n");

  for (i = 0; i < ARRAY_SIZE(aes_mode); i++) {
    for (j = 0; j < 3; j++) {
      memset(key_name, 0, sizeof(key_name));
      snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, j);

      ret = security->set_key((see_algorithm)aes_info[j][0], key_name,
                              aes_input, aes_info[j][1]);
      ret += security->aes_encryption((see_aes_mode)aes_mode[i][0], key_name,
        iv, sizeof(iv), aes_input, aes_mode[i][1], &out, &outlen);
      ret += security->aes_decryption((see_aes_mode)aes_mode[i][0], key_name,
        iv, sizeof(iv), out, outlen, &check, &checklen);
      ret += security->remove_key((see_algorithm)aes_info[j][0], key_name);

      if (!check) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf("[%d] ", cnt++);
        if (ret || memcmp(aes_input, check, checklen)) {
          test_result++;
          see_selfprintf(" fail\n");
        } else {
          see_selfprintf(" success\n");
        }

        if (out) {
          free(out);
          out = NULL;
        }

        free(check);
        check = NULL;
      }
    }
  }

  for (i = 0; i < ARRAY_SIZE(aes_mode); i++) {
    for (j = 0; j < 3; j++) {
      memset(key_name, 0, sizeof(key_name));
      snprintf(key_name, sizeof(key_name), "%s/%X",
               SECURE_STORAGE_MEMORY, cnt % 4);

      ret = security->set_key((see_algorithm)aes_info[j][0], key_name,
                              aes_input, aes_info[j][1]);
      ret += security->aes_encryption((see_aes_mode)aes_mode[i][0], key_name,
        iv, sizeof(iv), aes_input, aes_mode[i][1], &out, &outlen);
      ret += security->aes_decryption((see_aes_mode)aes_mode[i][0], key_name,
        iv, sizeof(iv), out, outlen, &check, &checklen);
      ret += security->remove_key((see_algorithm)aes_info[j][0], key_name);

      if (!check) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf("[%d] ", cnt++);
        if (ret || memcmp(aes_input, check, checklen)) {
          test_result++;
          see_selfprintf(" fail\n");
        } else {
          see_selfprintf(" success\n");
        }

        if (out) {
          free(out);
          out = NULL;
        }

        free(check);
        check = NULL;
      }
    }
  }

  if (out) {
    free(out);
    out = NULL;
  }
  if (check) {
    free(check);
    check = NULL;
  }

  return test_result;
}

static int security_secure_storage(artik::Security *security) {
  int j, ret = 0;
  unsigned int test_result = 0;
  unsigned char *input = NULL;
  unsigned int inlen[3] = { 18, 32768, 32769 };
  unsigned char *out;
  unsigned int outlen = 0;
  char key_name[20] = { 0 };

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : secure storage\n");
  fprintf(stderr, "------------------------------------------------------\n");

  input = (unsigned char *)malloc(inlen[2]);
  if (!input) {
      test_result++;
      see_selfprintf(" fail\n");
      return test_result;
  }

  for (j = 0; j < 32; j++) {
    see_selfprintf("[%d] ", j);

    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X",
             SECURE_STORAGE_DEFAULT, j % 4);

    /* positive case 1 */
    ret = security->write_secure_storage(key_name, 0, input, inlen[0]);
    ret += security->read_secure_storage(key_name, 0, inlen[0], &out, &outlen);
    if (!out) {
      test_result++;
      see_selfprintf(" fail\n");
      continue;
    }

    ret += security->remove_secure_storage(key_name);
    if (ret || memcmp(input, out, inlen[0])) {
      free(out);
      out = NULL;
      test_result++;
      see_selfprintf(" fail\n");
      continue;
    }

    free(out);
    out = NULL;

    /* positive case 2 */
    ret = security->write_secure_storage(key_name, 0, input, inlen[1]);
    ret += security->read_secure_storage(key_name, 0, inlen[1], &out, &outlen);
    if (!out) {
      test_result++;
      see_selfprintf(" fail\n");
      continue;
    }
    ret += security->remove_secure_storage(key_name);
    if (ret || memcmp(input, out, inlen[1])) {
      free(out);
      out = NULL;
      test_result++;
      see_selfprintf(" fail\n");
      continue;
    }

    free(out);
    out = NULL;

    /* negative case 1 : exceed max size */
    ret = security->write_secure_storage(key_name, 0, input, inlen[2]);
    ret += security->read_secure_storage(key_name, 0, inlen[2], &out, &outlen);
    ret += security->remove_secure_storage(key_name);
    if (!ret) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf(" success\n");
    }

    if (out) {
      free(out);
      out = NULL;
    }
  }

  free(input);

  return test_result;
}

#define SEE_GENERATE_KEY_TC 12
static int security_generate_key(artik::Security *security) {
  struct hmac_key_param hmac_param;
  struct rsa_key_param rsa_param;
  int i, j, ret = 0, cnt = 0;
  unsigned int test_result = 0;
  char key_name_sk[20] = { 0 };
  char key_name_mem[20] = { 0 };
  unsigned int genkey_input[SEE_GENERATE_KEY_TC][3] = {
    {AES_128, 16, SEE_OK}, {AES_192, 24, SEE_OK}, {AES_256, 32, SEE_OK},
    {HMAC_ALGORITHM, 0, SEE_ERROR}, {HMAC_ALGORITHM, 512, SEE_OK},
    {HMAC_ALGORITHM, 513, SEE_ERROR},
    {ECC_BRAINPOOL_P256R1, 0, SEE_OK}, {ECC_SEC_P256R1, 0, SEE_OK},
    {ECC_SEC_P384R1, 0, SEE_OK}, {ECC_SEC_P521R1, 0, SEE_OK},
    {0xffff, 0, SEE_INVALID_INPUT_PARAMS}
  };

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : generate key\n");
  fprintf(stderr, "------------------------------------------------------\n");

  for (j = 0; j < SEE_GENERATE_KEY_TC; j++) {
    for (i = 0; i < 1; i++) {
      see_selfprintf("[%d] ", cnt++);

      memset(key_name_sk, 0, sizeof(key_name_sk));
      snprintf(key_name_sk, sizeof(key_name_sk), "%s/%X",
               SECURE_STORAGE_DEFAULT, i);
      memset(key_name_mem, 0, sizeof(key_name_mem));
      snprintf(key_name_mem, sizeof(key_name_mem), "%s/%X",
               SECURE_STORAGE_MEMORY, i);

      if ((genkey_input[j][0] & 0xF000) == HMAC_ALGORITHM)
        hmac_param.key_size = genkey_input[j][1];

      ret = security->generate_key((see_algorithm)genkey_input[j][0],
                                   key_name_sk, &hmac_param);
      ret += security->generate_key((see_algorithm)genkey_input[j][0],
                                    key_name_mem, &hmac_param);
      ret += security->remove_key((see_algorithm)genkey_input[j][0],
                                  key_name_sk);
      ret += security->remove_key((see_algorithm)genkey_input[j][0],
                                  key_name_mem);

      if (ret && genkey_input[j][2]) {
        see_selfprintf(" success\n");
      } else if (!ret && !genkey_input[j][2]) {
        see_selfprintf(" success\n");
      } else {
        test_result++;
        see_selfprintf(" fail\n");
      }
    }
  }

  unsigned char exp1[] = { 0x00, 0x00, 0x00, 0x00 };
  unsigned char exp2[] = { 0x00, 0x01, 0x00, 0x01 };
  unsigned int genkey_input_rsa[4][3] = {
    {RSA_1024, 1}, {RSA_2048, 1},
    {RSA_1024, 0}, {RSA_2048, 0}
  };
  unsigned char *exp[] = {
    exp1, exp1, exp2, exp2
  };

  for (j = 0; j < 4; j++) {
    see_selfprintf("[%d] ", cnt++);

    memset(key_name_sk, 0, sizeof(key_name_sk));
    snprintf(key_name_sk, sizeof(key_name_sk), "%s/%X",
             SECURE_STORAGE_DEFAULT, j);

    rsa_param.exponent_size = 4;
    rsa_param.exponent = reinterpret_cast<unsigned char*>(exp[j]);

    ret = security->generate_key((see_algorithm)genkey_input_rsa[j][0],
                                 key_name_sk, &rsa_param);
    ret += security->remove_key((see_algorithm)genkey_input_rsa[j][0],
                                key_name_sk);

    if (ret && genkey_input_rsa[j][1]) {
      see_selfprintf(" success\n");
    } else if (!ret && !genkey_input_rsa[j][1]) {
      see_selfprintf(" success\n");
    } else {
      test_result++;
      see_selfprintf(" fail\n");
    }
  }

  return test_result;
}

#define SEE_REMOVE_KEY_TC 5

static int security_setup_remove_key(artik::Security *security) {
  char key_name[20] = { 0 };
  int ret, i, j, cnt = 0;
  unsigned int test_result = 0;
  unsigned int key_size[SEE_REMOVE_KEY_TC] = { 16, 24, 32, 128, 128 };
  unsigned int key_type[SEE_REMOVE_KEY_TC] = {
    AES_128, AES_192, AES_256,
    HMAC_ALGORITHM, HMAC_ALGORITHM
  };
  unsigned char key[1280];

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : setup/remove key\n");
  fprintf(stderr, "------------------------------------------------------\n");

  memset(key, 0xa5, sizeof(key));

  for (i = 0; i < SEE_REMOVE_KEY_TC; i++) {
    for (j = 0; j < 9; j++) {
      memset(key_name, 0, sizeof(key_name));
      snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, j);

      ret = security->set_key((see_algorithm)key_type[i], key_name, key,
                              key_size[i]);
      ret += security->remove_key((see_algorithm)key_type[i], key_name);

      see_selfprintf("[%d] ", cnt++);
      if (j == 8 && ret) {
        see_selfprintf(" success\n");
      } else if (ret) {
        test_result++;
        see_selfprintf(" fail : %d\n", ret);
      } else {
        see_selfprintf(" success\n");
      }
    }
  }

  for (i = 0; i < SEE_REMOVE_KEY_TC; i++) {
    for (j = 0; j < 5; j++) {
      memset(key_name, 0, sizeof(key_name));
      snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_MEMORY, j);

      ret = security->set_key((see_algorithm)key_type[i], key_name, key,
                              key_size[i]);
      ret += security->remove_key((see_algorithm)key_type[i], key_name);

      see_selfprintf("[%d] ", cnt++);
      if (j == 4 && ret) {
        see_selfprintf(" success\n");
      } else if (ret) {
        test_result++;
        see_selfprintf(" fail : %d\n", ret);
      } else {
        see_selfprintf(" success\n");
      }
    }
  }

  return test_result;
}

#define SEE_GET_HASH_TC 4
static int security_get_hash(artik::Security *security) {
  int ret, i;
  unsigned int test_result = 0;
  unsigned char input[300] = { 0 };
  unsigned char *out = NULL;
  unsigned int outlen;
  unsigned int hash_type[SEE_GET_HASH_TC] = {
    HASH_SHA1_160, HASH_SHA2_256,
    HASH_SHA2_384, HASH_SHA2_512
  };

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : get_hash\n");
  fprintf(stderr, "------------------------------------------------------\n");

  for (i = 0; i < SEE_GET_HASH_TC; i++) {
    see_selfprintf("[%d] ", i);
    ret = security->get_hash((see_hash_mode)hash_type[i], input, sizeof(input),
                             &out, &outlen);

    if (ret) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf(" success\n");
    }

    if (out) {
      free(out);
      out = NULL;
    }
  }

  if (out) {
    free(out);
    out = NULL;
  }

  return test_result;
}

#define SEE_GET_HMAC_TC 4
static int security_get_hmac(artik::Security *security) {
  int cnt = 0, ret = 0;
  unsigned int i, j, test_result = 0;
  char key_name[8] = { 0 };
  unsigned char input_hmac[300] = { 0 };
  unsigned int input_size[] = {32, 64, 96, 128, 160};
  unsigned int input_oid[SEE_GET_HMAC_TC] = {
    HASH_SHA1_160, HASH_SHA2_256, HASH_SHA2_384, HASH_SHA2_512,
  };
  unsigned char *out = NULL;
  unsigned int outlen = 0;

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : get_hmac\n");
  fprintf(stderr, "------------------------------------------------------\n");

  for (i = 0; i < sizeof(input_size)/sizeof(int); i++) {
    for (j = 0; j < SEE_GET_HMAC_TC; j++) {
      memset(key_name, 0, sizeof(key_name));
      snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, j);

      ret = security->set_key(HMAC_ALGORITHM, key_name,
        input_hmac, input_size[i]);
      ret += security->get_hmac((see_hash_mode)input_oid[j], key_name,
        input_hmac, sizeof(input_hmac), &out, &outlen);
      ret += security->remove_key(HMAC_ALGORITHM, key_name);

      see_selfprintf("[%d] ", cnt++);

      if (!ret) {
        see_selfprintf(" success\n");
      } else {
        test_result++;
        see_selfprintf(" fail\n");
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }
    }
  }

  for (i = 0; i < sizeof(input_size)/sizeof(int); i++) {
    for (j = 0; j < SEE_GET_HMAC_TC; j++) {
      memset(key_name, 0, sizeof(key_name));
      snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_MEMORY, j);

      ret = security->set_key(HMAC_ALGORITHM, key_name,
        input_hmac, input_size[i]);
      ret += security->get_hmac((see_hash_mode)input_oid[j], key_name,
        input_hmac, sizeof(input_hmac), &out, &outlen);
      ret += security->remove_key(HMAC_ALGORITHM, key_name);

      see_selfprintf("[%d] ", cnt++);

      if (!ret) {
        see_selfprintf(" success\n");
      } else {
        test_result++;
        see_selfprintf(" fail\n");
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }
    }
  }

  if (out != NULL) {
    free(out);
    out = NULL;
  }

  return test_result;
}

#define SEE_RSASSA_SV_TC 16
static int security_rsassa_sign_verify(artik::Security *security) {
  char key_name[8] = { 0 };
  int ret = 1, i, j, cnt = 0;
  unsigned int test_result = 0;
  unsigned int algo_type[SEE_RSASSA_SV_TC] = {
      RSASSA_1024_PKCS1_V1_5_SHA160,
      RSASSA_1024_PKCS1_PSS_MGF1_SHA160,
      RSASSA_1024_PKCS1_V1_5_SHA256,
      RSASSA_1024_PKCS1_PSS_MGF1_SHA256,
      RSASSA_1024_PKCS1_V1_5_SHA384,
      RSASSA_1024_PKCS1_PSS_MGF1_SHA384,
      RSASSA_1024_PKCS1_V1_5_SHA512,
      RSASSA_1024_PKCS1_PSS_MGF1_SHA512,
      RSASSA_2048_PKCS1_V1_5_SHA160,
      RSASSA_2048_PKCS1_PSS_MGF1_SHA160,
      RSASSA_2048_PKCS1_V1_5_SHA256,
      RSASSA_2048_PKCS1_PSS_MGF1_SHA256,
      RSASSA_2048_PKCS1_V1_5_SHA384,
      RSASSA_2048_PKCS1_PSS_MGF1_SHA384,
      RSASSA_2048_PKCS1_V1_5_SHA512,
      RSASSA_2048_PKCS1_PSS_MGF1_SHA512,
  };
  unsigned int hash_type[SEE_RSASSA_SV_TC] = {
      HASH_SHA1_160, HASH_SHA1_160, HASH_SHA2_256, HASH_SHA2_256,
      HASH_SHA2_384, HASH_SHA2_384, HASH_SHA2_512, HASH_SHA2_512,
      HASH_SHA1_160, HASH_SHA1_160, HASH_SHA2_256, HASH_SHA2_256,
      HASH_SHA2_384, HASH_SHA2_384, HASH_SHA2_512, HASH_SHA2_512
  };
  unsigned char msg[300];
  unsigned int hash_size;
  unsigned int salt_size[SEE_RSASSA_SV_TC] = { 0, 20, 0, 32, 0, 48, 0, 48, 0,
                                              20, 0, 32, 0, 48, 0, 64 };
  unsigned char *hash = NULL;
  unsigned char *out = NULL;
  unsigned int outlen = 0;

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : rsassa_sign_verify\n");
  fprintf(stderr, "------------------------------------------------------\n");

  memset(msg, 0x35, sizeof(msg));

  for (i = 0; i < 9; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    for (j = 0; j < SEE_RSASSA_SV_TC; j++) {
      if (j < 8)
        ret = security->set_key(RSA_1024, key_name,
          rsa1024_sample, sizeof(rsa1024_sample));
      else
        ret = security->set_key(RSA_2048, key_name,
          rsa2048_sample, sizeof(rsa2048_sample));

      if (j != 6 && j != 7) {
        ret += security->get_hash((see_hash_mode)hash_type[j], msg, sizeof(msg),
          &hash, &hash_size);
        ret += security->get_rsa_signature((see_rsa_mode)algo_type[j], key_name,
          hash, hash_size, salt_size[j], &out, &outlen);
        ret += security->verify_rsa_signature((see_rsa_mode)algo_type[j],
                         key_name, hash, hash_size, salt_size[j], out, outlen);
      }

      if (j < 8)
        ret += security->remove_key(RSA_1024, key_name);
      else
        ret += security->remove_key(RSA_2048, key_name);

      see_selfprintf("[%d] ", cnt++);
      if (i == 8 && ret) {
        see_selfprintf(" success\n");
      } else if (ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (hash != NULL) {
        free(hash);
        hash = NULL;
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }
    }
  }

  for (i = 0; i < 9; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_MEMORY, i % 4);

    for (j = 0; j < SEE_RSASSA_SV_TC; j++) {
      if (j < 8)
        ret = security->set_key(RSA_1024, key_name,
          rsa1024_sample, sizeof(rsa1024_sample));
      else
        ret = security->set_key(RSA_2048, key_name,
          rsa2048_sample, sizeof(rsa2048_sample));

      if (j != 6 && j != 7) {
        ret += security->get_hash((see_hash_mode)hash_type[j], msg,
                                  sizeof(msg), &hash, &hash_size);
        ret += security->get_rsa_signature((see_rsa_mode)algo_type[j],
                        key_name, hash, hash_size, salt_size[j], &out, &outlen);
        ret += security->verify_rsa_signature((see_rsa_mode)algo_type[j],
                         key_name, hash, hash_size, salt_size[j], out, outlen);
      }

      if (j < 8)
        ret += security->remove_key(RSA_1024, key_name);
      else
        ret += security->remove_key(RSA_2048, key_name);

      see_selfprintf("[%d] ", cnt++);
      if (i == 8 && ret) {
        see_selfprintf(" success\n");
      } else if (ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (hash != NULL) {
        free(hash);
        hash = NULL;
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }
    }
  }

  if (out != NULL) {
    free(out);
    out = NULL;
  }

  return test_result;
}

#define SEE_ECDSA_SV_TC 16
static int security_ecdsa_sign_verify(artik::Security *security) {
  char key_name[10] = { 0 };
  int ret = 1, i, j, cnt = 0;
  unsigned int test_result = 0;
  unsigned int algo_type[SEE_ECDSA_SV_TC] = {
    (ECC_BRAINPOOL_P256R1),
    (ECC_BRAINPOOL_P256R1),
    (ECC_BRAINPOOL_P256R1),
    (ECC_BRAINPOOL_P256R1),
    (ECC_SEC_P256R1),
    (ECC_SEC_P256R1),
    (ECC_SEC_P256R1),
    (ECC_SEC_P256R1),
    (ECC_SEC_P384R1),
    (ECC_SEC_P384R1),
    (ECC_SEC_P384R1),
    (ECC_SEC_P384R1),
    (ECC_SEC_P521R1),
    (ECC_SEC_P521R1),
    (ECC_SEC_P521R1),
    (ECC_SEC_P521R1)
  };
  unsigned int hash_size[SEE_ECDSA_SV_TC] = { 20, 32, 48, 64, 20, 32, 48, 64,
                                              20, 32, 48, 64, 20, 32, 48, 64 };
  unsigned char *hash = NULL;
  unsigned char *out = NULL;
  unsigned int outlen = 0;

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : ecdsa_sign_verify\n");
  fprintf(stderr, "------------------------------------------------------\n");

  for (i = 0; i < 9; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    for (j = 0; j < SEE_ECDSA_SV_TC; j++) {
      if (j < 4) {
        ret = security->set_key(ECC_BRAINPOOL_P256R1, key_name,
          test_ecdsa_dev_bp, sizeof(test_ecdsa_dev_bp));
      } else if (j < 8) {
        ret = security->set_key(ECC_SEC_P256R1, key_name,
          test_ecdsa_256_dev_nist, sizeof(test_ecdsa_256_dev_nist));
      } else if (j < 12) {
        ret = security->set_key(ECC_SEC_P384R1, key_name,
          test_ecdsa_384_dev_nist, sizeof(test_ecdsa_384_dev_nist));
      } else {
        ret = security->set_key(ECC_SEC_P521R1, key_name,
          test_ecdsa_dev_nist, sizeof(test_ecdsa_dev_nist));
      }

      ret += security->get_random_bytes(hash_size[j], &hash);
      ret += security->get_ecdsa_signature((see_algorithm)algo_type[j],
                                  key_name, hash, hash_size[j], &out, &outlen);
      ret += security->verify_ecdsa_signature((see_algorithm)algo_type[j],
                                    key_name, hash, hash_size[j], out, outlen);
      ret += security->remove_key((see_algorithm)algo_type[j], key_name);

      see_selfprintf("[%d] ", cnt++);

      if (i == 8 && ret) {
        see_selfprintf(" success\n");
      } else if (ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }

      if (hash != NULL) {
        free(hash);
        hash = NULL;
      }
    }
  }

  for (i = 0; i < 4; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_MEMORY, i);

    for (j = 0; j < SEE_ECDSA_SV_TC; j++) {
      if (j < 4) {
        ret = security->set_key(ECC_BRAINPOOL_P256R1, key_name,
          test_ecdsa_dev_bp, sizeof(test_ecdsa_dev_bp));
      } else if (j < 8) {
        ret = security->set_key(ECC_SEC_P256R1, key_name,
          test_ecdsa_256_dev_nist, sizeof(test_ecdsa_256_dev_nist));
      } else if (j < 12) {
        ret = security->set_key(ECC_SEC_P384R1, key_name,
          test_ecdsa_384_dev_nist, sizeof(test_ecdsa_384_dev_nist));
      } else {
        ret = security->set_key(ECC_SEC_P521R1, key_name,
          test_ecdsa_dev_nist, sizeof(test_ecdsa_dev_nist));
      }

      ret += security->get_random_bytes(hash_size[j], &hash);
      ret += security->get_ecdsa_signature((see_algorithm)algo_type[j],
                                  key_name, hash, hash_size[j], &out, &outlen);
      ret += security->verify_ecdsa_signature((see_algorithm)algo_type[j],
                                    key_name, hash, hash_size[j], out, outlen);
      ret += security->remove_key((see_algorithm)algo_type[j], key_name);

      see_selfprintf("[%d] ", cnt++);

      if (ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }

      if (hash != NULL) {
        free(hash);
        hash = NULL;
      }
    }
  }

  if (out != NULL) {
    free(out);
    out = NULL;
  }

  return test_result;
}

static int security_set_compute_dhm_params(artik::Security *security) {
  char key_name[8] = {0};
  int ret = 1, cnt = 0;
  unsigned int i, test_result = 0;
  unsigned char *pub = NULL;
  unsigned int publen = 0;
  unsigned char *secret = NULL;
  unsigned int secretlen = 0;

  unsigned int algo;
  unsigned char *input_key[][3] = {
      {dh1024_key, dh1024_key_pub, dh1024_secret},
      {dh1024_5114_key, dh1024_5114_key_pub, dh1024_5114_secret},
      {dh2048_key, dh2048_key_pub, dh2048_secret},
      {dh2048_5114_key, dh2048_5114_key_pub, dh2048_5114_secret}
  };
  unsigned int input_key_size[][3] = {
      {sizeof(dh1024_key), sizeof(dh1024_key_pub), sizeof(dh1024_secret)},
      {sizeof(dh1024_5114_key), sizeof(dh1024_5114_key_pub),
       sizeof(dh1024_5114_secret)},
      {sizeof(dh2048_key), sizeof(dh2048_key_pub), sizeof(dh2048_secret)},
      {sizeof(dh2048_5114_key), sizeof(dh2048_5114_key_pub),
       sizeof(dh2048_5114_secret)}
  };

  unsigned char *input_param[] = {
      dh1024_pg, dh1024_5114_pg, dh2048_pg, dh2048_5114_pg
  };
  unsigned int input_param_size[] = {
      sizeof(dh1024_pg), sizeof(dh1024_5114_pg), sizeof(dh2048_pg),
      sizeof(dh2048_5114_pg)
  };

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : generate_compute_dhm_params\n");
  fprintf(stderr, "------------------------------------------------------\n");

  /*
   * Validation Test
   */
  for (i = 0; i < sizeof(input_key_size)/(sizeof(int)*3); i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    if (i < 2)
      algo = DH_1024;
    else
      algo = DH_2048;

    ret = security->set_key((see_algorithm) algo, key_name, input_key[i][0],
                            input_key_size[i][0]);
    ret += security->compute_dhm_params(key_name,
        input_key[i][1], input_key_size[i][1],
        &secret, &secretlen);
    ret += security->remove_key((see_algorithm) algo, key_name);
    if (!secret) {
        test_result++;
        see_selfprintf(" fail\n");
    } else {
      see_selfprintf("[%d] ", cnt++);

      if (ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        if (!memcmp(input_key[i][2], secret, secretlen)) {
          see_selfprintf(" success\n");
        } else {
          test_result++;
          see_selfprintf(" fail\n");
        }
      }

      free(secret);
      secret = NULL;
      secretlen = 0;
    }
  }

  /*
   * Function Test
   */
  for (i = 0; i < sizeof(input_param_size)/sizeof(int); i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    ret = security->set_dhm_params(key_name,
        input_param[i], input_param_size[i], &pub, &publen);
    ret += security->compute_dhm_params(key_name,
        pub, publen, &secret, &secretlen);
    ret += security->remove_key(DH_ALGORITHM, key_name);

    see_selfprintf("[%d] ", cnt++);

    if (ret) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf(" success\n");
    }

    if (pub != NULL && publen > 0) {
      free(pub);
      pub = NULL;
      publen = 0;
    }

    if (secret != NULL && secretlen > 0) {
      free(secret);
      secret = NULL;
      secretlen = 0;
    }
  }

  if (pub != NULL && publen > 0) {
    free(pub);
    pub = NULL;
  }

  if (secret != NULL && secretlen > 0) {
    free(secret);
    secret = NULL;
  }

  return test_result;
}

static int security_set_compute_ecdh_params(artik::Security *security) {
  char key_name[8] = {0};
  int ret = 1, cnt = 0;
  unsigned int i, test_result = 0;
  unsigned char *pub = NULL;
  unsigned int publen = 0;
  unsigned char *secret = NULL;
  unsigned int secretlen = 0;
  unsigned int genkey_input[4] = {
    ECC_BRAINPOOL_P256R1, ECC_SEC_P256R1, ECC_SEC_P384R1, ECC_SEC_P521R1
  };

  unsigned char brainpool256_key[] = {
    0x30, 0x78, 0x02, 0x01, 0x01, 0x04, 0x20, 0x99, 0xB4, 0xFA, 0x33, 0xAC,
    0x80, 0xAF, 0xD2, 0x49, 0x7C, 0x99, 0x03, 0x3A, 0x38, 0x82, 0xB2, 0x1E,
    0xD7, 0xED, 0xD5, 0x6A, 0xE6, 0xC7, 0xB8, 0xA6, 0x78, 0x32, 0x76, 0xED,
    0x43, 0xEE, 0x6C, 0xA0, 0x0B, 0x06, 0x09, 0x2B, 0x24, 0x03, 0x03, 0x02,
    0x08, 0x01, 0x01, 0x07, 0xA1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x18, 0xD9,
    0x6C, 0x32, 0xEC, 0x0B, 0x1F, 0xED, 0x88, 0x35, 0x46, 0x8D, 0x5B, 0x13,
    0xA4, 0xF8, 0x12, 0x44, 0x05, 0xC6, 0x11, 0xD5, 0x95, 0xEB, 0x8D, 0x86,
    0x4D, 0x41, 0xBF, 0x3B, 0x6C, 0x2D, 0x58, 0x04, 0xB9, 0xE9, 0xFC, 0x4D,
    0x41, 0x60, 0x50, 0xF0, 0xD5, 0xEF, 0xDA, 0x6B, 0x08, 0xD2, 0xB3, 0x28,
    0x3A, 0x85, 0x03, 0xAA, 0x13, 0xBC, 0xAE, 0x35, 0xEB, 0x30, 0x6C, 0x91,
    0x69, 0xAC
  };
  unsigned char brainpool256_secret[] = {
    0x83, 0xD0, 0x11, 0xD6, 0xD4, 0xB1, 0x02, 0x91, 0x5A, 0xA3, 0xA3, 0xA9,
    0xBD, 0xBA, 0xF2, 0x7C, 0x5D, 0x9B, 0x9F, 0x77, 0xC7, 0x3C, 0x91, 0x82,
    0x4B, 0x0D, 0x69, 0x34, 0xAC, 0x07, 0xD2, 0xCC
  };

  unsigned char secp256r1_key[] = {
    0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0x91, 0x22, 0xDB, 0x5F, 0xF9,
    0xBE, 0x23, 0x14, 0xBE, 0x87, 0xC8, 0xF3, 0xF2, 0x1C, 0x83, 0xA8, 0x3C,
    0x9B, 0x9F, 0x4A, 0x3C, 0xC8, 0x0B, 0x7F, 0x09, 0xF8, 0x5E, 0x66, 0x5F,
    0x80, 0x23, 0xC7, 0xA0, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
    0x03, 0x01, 0x07, 0xA1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x3A, 0xA0, 0xD9,
    0x88, 0x1C, 0x74, 0x98, 0x12, 0x82, 0xE5, 0x3F, 0x91, 0xC6, 0xD1, 0x82,
    0x2E, 0xCF, 0x4F, 0x3A, 0xA1, 0x39, 0xCB, 0xA0, 0x4E, 0xBE, 0x4C, 0x22,
    0xB2, 0x0E, 0xB4, 0x4F, 0x9F, 0x9C, 0x43, 0x35, 0x16, 0x86, 0x0B, 0x20,
    0x81, 0xFF, 0x33, 0xDD, 0x1B, 0x2D, 0xDE, 0xB0, 0x12, 0x20, 0x44, 0x9B,
    0x1B, 0x00, 0x55, 0x4C, 0x62, 0x6B, 0x40, 0x9C, 0x84, 0xB9, 0x3B, 0xB9,
    0xCE
  };
  unsigned char secp256r1_secret[] = {
    0x64, 0x51, 0x5A, 0x89, 0x7D, 0x36, 0x77, 0x9A, 0xC9, 0x66, 0x99, 0x82,
    0x34, 0x37, 0x27, 0x52, 0xFF, 0xF8, 0xC4, 0xF7, 0x8C, 0x5F, 0xB0, 0x80,
    0x96, 0xFD, 0xA4, 0x16, 0xD2, 0xF9, 0x50, 0xB2
  };

  unsigned char secp384r1_key[] = {
    0x30, 0x81, 0xA4, 0x02, 0x01, 0x01, 0x04, 0x30, 0xEE, 0x4C, 0x4C, 0x00,
    0x53, 0xA3, 0xAF, 0x01, 0x4E, 0xFE, 0xF8, 0x81, 0x87, 0x2B, 0xEE, 0x6D,
    0xD9, 0x93, 0x98, 0x07, 0x52, 0x59, 0x46, 0x49, 0xF2, 0x5D, 0x84, 0x4D,
    0x5A, 0x10, 0x18, 0x6E, 0xA7, 0xB8, 0x02, 0x76, 0xEA, 0x23, 0xB3, 0x17,
    0x97, 0xD8, 0xEF, 0x3D, 0x02, 0x47, 0xB3, 0x77, 0xA0, 0x07, 0x06, 0x05,
    0x2B, 0x81, 0x04, 0x00, 0x22, 0xA1, 0x64, 0x03, 0x62, 0x00, 0x04, 0x5B,
    0x91, 0xD2, 0x0A, 0x7D, 0xA5, 0xA5, 0xCB, 0x36, 0x22, 0x4F, 0x25, 0xB6,
    0xF8, 0xC5, 0x2B, 0xFF, 0xCB, 0xFA, 0x0B, 0x36, 0xDD, 0x64, 0xEE, 0x62,
    0x9F, 0x80, 0xE5, 0x15, 0x10, 0xF4, 0x3E, 0xB9, 0xA4, 0x03, 0x83, 0x74,
    0xB6, 0xB5, 0x01, 0x17, 0x32, 0xDF, 0x8A, 0xE9, 0x7C, 0xE1, 0x47, 0x57,
    0x3E, 0x42, 0x8D, 0xD5, 0x9C, 0x6A, 0x63, 0x9F, 0x4A, 0xA1, 0x48, 0x64,
    0xC8, 0xE3, 0xF4, 0xBC, 0x93, 0x16, 0x9B, 0x22, 0x39, 0x2B, 0x95, 0xA0,
    0x97, 0x04, 0x50, 0xAD, 0x9F, 0x9E, 0x41, 0x4E, 0x34, 0x51, 0x47, 0x48,
    0x80, 0x7C, 0xBF, 0x18, 0xBB, 0xE2, 0x91, 0x53, 0xA2, 0x0C, 0x5B
  };
  unsigned char secp384r1_secret[] = {
    0xB1, 0x10, 0x23, 0x91, 0xD4, 0x7F, 0x88, 0x64, 0xA3, 0xF4, 0x52, 0x99,
    0xAB, 0xE2, 0x85, 0x70, 0x7A, 0x3B, 0x03, 0xA6, 0xA2, 0xC1, 0xBA, 0x67,
    0xF8, 0xE6, 0x2D, 0x9D, 0xC3, 0xEB, 0x64, 0xBB, 0xB2, 0x3B, 0xBE, 0x78,
    0x60, 0xB4, 0x83, 0x9C, 0x7D, 0x03, 0x11, 0xEB, 0xE8, 0x32, 0x46, 0xC8
  };

  unsigned char secp521r1_key[] = {
    0x30, 0x81, 0xDC, 0x02, 0x01, 0x01, 0x04, 0x42, 0x01, 0x0B, 0xB5, 0x16,
    0x4D, 0xE1, 0x79, 0x83, 0x79, 0xC9, 0xCE, 0x40, 0x11, 0xF6, 0xF4, 0xF7,
    0x1D, 0x8F, 0xDB, 0x7E, 0x0D, 0xE9, 0x70, 0xD7, 0x99, 0x4F, 0x67, 0x5F,
    0x01, 0xAA, 0x4D, 0xC3, 0x45, 0x2F, 0x27, 0x8A, 0xA0, 0x9B, 0x57, 0x96,
    0x41, 0x37, 0x49, 0xEC, 0xCF, 0xB6, 0x01, 0xCA, 0xE5, 0xE7, 0x46, 0x52,
    0x86, 0x5D, 0x7C, 0x9E, 0x28, 0xEF, 0x4F, 0xE7, 0x74, 0x41, 0x6A, 0xF0,
    0x36, 0x6A, 0xA0, 0x07, 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x23, 0xA1,
    0x81, 0x89, 0x03, 0x81, 0x86, 0x00, 0x04, 0x00, 0xFB, 0x5B, 0x50, 0xC5,
    0xA4, 0x8E, 0xB7, 0x07, 0x7C, 0x4C, 0x5D, 0xF2, 0xA1, 0x87, 0x7A, 0x6C,
    0xDA, 0xAC, 0x87, 0x5F, 0xEF, 0x54, 0xA5, 0x61, 0x5A, 0x47, 0x31, 0xFC,
    0xC0, 0x1A, 0x4E, 0xF1, 0x5F, 0x3B, 0x6C, 0xA1, 0xE4, 0xD2, 0xAC, 0x24,
    0x62, 0x1A, 0xC5, 0x75, 0x99, 0x86, 0x0B, 0x32, 0xC6, 0x54, 0x29, 0x24,
    0xDE, 0x95, 0x92, 0x5A, 0x30, 0xF4, 0x56, 0x8C, 0xFC, 0x56, 0x11, 0x9D,
    0x98, 0x01, 0x0C, 0x20, 0x97, 0x9C, 0x1C, 0xD5, 0x1B, 0x8C, 0x43, 0xDB,
    0x71, 0x84, 0x26, 0x0B, 0xE4, 0xEE, 0x96, 0xEF, 0xB8, 0x88, 0x4E, 0xAD,
    0xBA, 0xF4, 0xF6, 0x93, 0xC2, 0x72, 0x13, 0x6F, 0x0D, 0xD2, 0xBA, 0x37,
    0x87, 0x44, 0xD2, 0x02, 0x2D, 0xA4, 0x56, 0x01, 0xFC, 0xEB, 0x44, 0xFA,
    0xDC, 0xBA, 0x46, 0xA3, 0x60, 0x8D, 0x7D, 0xFB, 0xA6, 0xFC, 0x2F, 0x68,
    0x61, 0x5E, 0x2C, 0x95, 0xB9, 0x13, 0x70
  };
  unsigned char secp521r1_secret[] = {
    0x00, 0x68, 0x55, 0x02, 0x03, 0xE4, 0x71, 0xAF, 0x51, 0x44, 0xB2, 0x08,
    0x2E, 0x82, 0x7E, 0x23, 0x79, 0x19, 0x30, 0xC9, 0x23, 0xF9, 0x70, 0xA4,
    0x9C, 0xFE, 0xD3, 0x23, 0x41, 0x11, 0x69, 0xC0, 0x6C, 0x97, 0x2C, 0x7D,
    0x08, 0xEE, 0x4C, 0xC0, 0x80, 0x0A, 0xE0, 0x36, 0x65, 0x9F, 0x6C, 0xA2,
    0x25, 0x55, 0x6C, 0x2F, 0xE8, 0x75, 0xA6, 0xA9, 0xF2, 0x71, 0x48, 0x73,
    0xAE, 0x03, 0xDC, 0x49, 0x11, 0xF0
  };

  unsigned char *keys[] = {
    brainpool256_key, secp256r1_key, secp384r1_key, secp521r1_key
  };
  unsigned int keys_size[] = {
    sizeof(brainpool256_key), sizeof(secp256r1_key), sizeof(secp384r1_key),
    sizeof(secp521r1_key)
  };
  unsigned char keys_name[][16] = {
    "brainpool256",
    "secp256r1",
    "secp384r1",
    "secp521r1"
  };
  unsigned char *secrets[] = {
    brainpool256_secret, secp256r1_secret, secp384r1_secret, secp521r1_secret
  };
  unsigned int secrets_size[] = {
    sizeof(brainpool256_secret), sizeof(secp256r1_secret),
    sizeof(secp384r1_secret), sizeof(secp521r1_secret)
  };

  int cmp_ret = 0;

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : generate_compute_ecdh_params\n");
  fprintf(stderr, "------------------------------------------------------\n");

  for (i = 0; i < sizeof(genkey_input)/sizeof(int); i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    ret = security->generate_ecdh_params((see_algorithm)genkey_input[i],
                                         key_name, &pub, &publen);
    ret += security->compute_ecdh_params(key_name,
        pub, publen, &secret, &secretlen);
    ret += security->remove_key((see_algorithm)genkey_input[i], key_name);

    see_selfprintf("[%d] ", cnt++);

    if (ret) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf(" success\n");
    }

    if (pub != NULL && publen > 0) {
      free(pub);
      pub = NULL;
      publen = 0;
    }

    if (secret != NULL && secretlen > 0) {
      free(secret);
      secret = NULL;
      secretlen = 0;
    }
  }

  for (i = 0; i < sizeof(genkey_input)/sizeof(int); i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    ret = security->set_key((see_algorithm) genkey_input[i], key_name, keys[i],
        keys_size[i]);
    ret += security->get_publickey((see_algorithm) genkey_input[i], key_name,
        &pub, &publen);
    ret += security->compute_ecdh_params(key_name,
        pub, publen, &secret, &secretlen);
    ret += security->remove_key((see_algorithm) genkey_input[i], key_name);

    if (!secret) {
      test_result++;
      see_selfprintf(" fail\n");
    } else {
      see_selfprintf("[%d] %s ", cnt++, keys_name[i]);

      cmp_ret = memcmp(secrets[i], secret, secrets_size[i]);

      if (ret || cmp_ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (pub != NULL && publen > 0) {
        free(pub);
        pub = NULL;
        publen = 0;
      }

      free(secret);
      secret = NULL;
      secretlen = 0;
    }
  }

  if (pub != NULL && publen > 0) {
    free(pub);
    pub = NULL;
  }

  if (secret != NULL && secretlen > 0) {
    free(secret);
    secret = NULL;
  }

  return test_result;
}

static int security_get_publickey(artik::Security *security) {
  struct rsa_key_param rsa_param;
  char key_name[8] = { 0 };
  int ret = 1, i, j, cnt = 0;
  unsigned int test_result = 0;
  unsigned char *out = NULL;
  unsigned int outlen = 0;
  unsigned int genkey_input[6][3] = {
    {ECC_BRAINPOOL_P256R1, 0, SEE_OK}, {ECC_SEC_P256R1, 0, SEE_OK},
    {ECC_SEC_P384R1, 0, SEE_OK}, {ECC_SEC_P521R1, 0, SEE_OK},
    {RSA_1024, 0, SEE_OK}, {RSA_2048, 0, SEE_OK}
  };
  unsigned char exp[] = { 0x00, 0x00, 0x00, 0x05 };
  unsigned char ecc_pair[] = {
      0x30, 0x77, 0x02, 0x01, 0x01, 0x04, 0x20, 0xA4, 0xF4, 0xDE, 0xDF, 0x15,
      0x8F, 0x0B, 0xB8, 0xEA, 0x94, 0x84, 0xE9, 0xF5, 0x9D, 0x9E, 0x38, 0xE0,
      0x1C, 0x00, 0xE7, 0xC2, 0x06, 0xDE, 0x9A, 0x15, 0x7C, 0xAF, 0x72, 0xA5,
      0x2A, 0x4C, 0x5C, 0xA0, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
      0x03, 0x01, 0x07, 0xA1, 0x44, 0x03, 0x42, 0x00, 0x04, 0xA3, 0x55, 0xAE,
      0xFA, 0xD1, 0x50, 0x43, 0x69, 0x66, 0x48, 0x19, 0x9C, 0x59, 0x71, 0x70,
      0x86, 0x59, 0xB7, 0x2E, 0x49, 0x97, 0x5B, 0x1E, 0x81, 0x09, 0x4E, 0x6C,
      0xB7, 0x53, 0x15, 0xC3, 0xA2, 0xF3, 0x69, 0xE6, 0x05, 0x48, 0x02, 0xE2,
      0xE8, 0xD1, 0x16, 0x65, 0x49, 0x00, 0x82, 0xCD, 0x15, 0xA0, 0xFD, 0x87,
      0xD5, 0x49, 0x83, 0x03, 0x62, 0x66, 0x29, 0xD5, 0x23, 0xA9, 0x83, 0xB4,
      0xCD
  };
  unsigned char ecc_pub[] = {
      0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02,
      0x01, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03,
      0x42, 0x00, 0x04, 0xA3, 0x55, 0xAE, 0xFA, 0xD1, 0x50, 0x43, 0x69, 0x66,
      0x48, 0x19, 0x9C, 0x59, 0x71, 0x70, 0x86, 0x59, 0xB7, 0x2E, 0x49, 0x97,
      0x5B, 0x1E, 0x81, 0x09, 0x4E, 0x6C, 0xB7, 0x53, 0x15, 0xC3, 0xA2, 0xF3,
      0x69, 0xE6, 0x05, 0x48, 0x02, 0xE2, 0xE8, 0xD1, 0x16, 0x65, 0x49, 0x00,
      0x82, 0xCD, 0x15, 0xA0, 0xFD, 0x87, 0xD5, 0x49, 0x83, 0x03, 0x62, 0x66,
      0x29, 0xD5, 0x23, 0xA9, 0x83, 0xB4, 0xCD
  };

  unsigned char rsa1024_pub[] = {
      0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
      0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81,
      0x89, 0x02, 0x81, 0x81, 0x00, 0xAC, 0x5A, 0x9D, 0xDA, 0xD4, 0x90, 0xCE,
      0xA1, 0xCD, 0x05, 0xE0, 0x84, 0xCD, 0x25, 0xB1, 0x8C, 0x8A, 0xAD, 0x8F,
      0xAC, 0xE3, 0xD7, 0x3D, 0x4B, 0xF3, 0xC6, 0xEF, 0xD2, 0x82, 0xCE, 0x3F,
      0xB4, 0x03, 0xEC, 0x60, 0xB9, 0x20, 0x39, 0xE8, 0x2E, 0x2D, 0xCF, 0x52,
      0xB9, 0x3D, 0x8B, 0x6C, 0x5F, 0xA5, 0xD6, 0xAB, 0x30, 0xD0, 0xD0, 0x0B,
      0x00, 0x2A, 0x0B, 0x21, 0xD3, 0x6A, 0x82, 0x6F, 0x37, 0xFF, 0xB9, 0x00,
      0xCD, 0x1E, 0xD7, 0xD6, 0x80, 0x73, 0x53, 0xF4, 0x75, 0xB9, 0x73, 0xA4,
      0x99, 0xEE, 0xB7, 0xE7, 0x79, 0xEE, 0x8A, 0xAD, 0x92, 0x0B, 0xE9, 0x82,
      0x08, 0xC4, 0x9E, 0xA1, 0x58, 0xE7, 0x92, 0x1B, 0x5C, 0x30, 0x7A, 0x01,
      0xC9, 0x9E, 0x1F, 0x80, 0x4E, 0x64, 0xBE, 0x19, 0x7E, 0x2A, 0x20, 0x1B,
      0xAB, 0xFF, 0x10, 0x85, 0x08, 0x60, 0x6E, 0xBD, 0xDE, 0xAF, 0xEA, 0x11,
      0xB5, 0x02, 0x03, 0x01, 0x00, 0x01
  };

  fprintf(stderr, "------------------------------------------------------\n");
  fprintf(stderr, "  SECURITY SDK TESTCASE : get_publickey\n");
  fprintf(stderr, "------------------------------------------------------\n");

  /*
   * ARTIK Device Public Key
   */
  ret = security->get_publickey(ECC_SEC_P256R1, ARTIK_DEVICE_KEY_ID,
                                &out, &outlen);
  // print_buffer("ECC Public Key", out, outlen);
  see_selfprintf("[%d] ", cnt++);
  if (ret) {
    test_result++;
    see_selfprintf(" fail\n");
  } else {
    see_selfprintf(" success\n");
  }

  if (out != NULL) {
    free(out);
    out = NULL;
  }

  unsigned char *sig = NULL;
  unsigned int siglen;
  unsigned char hash[32] = {0};

  memset(hash, 0, 32);

  memset(key_name, 0, sizeof(key_name));
  snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, 1);
  ret = security->set_key(ECC_SEC_P256R1, key_name, ecc_pair,
                          sizeof(ecc_pair));
  ret += security->get_ecdsa_signature(ECC_SEC_P256R1, key_name,
                                       hash, 32, &sig, &siglen);
  if (security->verify_ecdsa_signature(ECC_SEC_P256R1, key_name,
                                       hash, 32, sig, siglen) != 0)
    see_selfprintf("Signature verification fail\n");

  ret += security->get_publickey(ECC_SEC_P256R1, key_name, &out, &outlen);
  ret += security->remove_key(ECC_SEC_P256R1, key_name);

  if (!out) {
    test_result++;
    see_selfprintf(" fail : %d\n", ret);
  } else {
    see_selfprintf("[%d] ", cnt++);
    if (ret || memcmp(out, ecc_pub, sizeof(ecc_pub))) {
      test_result++;
      see_selfprintf(" fail : %d\n", ret);
    } else {
      see_selfprintf(" success\n");
    }

    free(out);
    out = NULL;
  }

  memset(key_name, 0, sizeof(key_name));
  snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, 2);
  ret = security->set_key(ECC_SEC_P256R1, key_name, ecc_pub, sizeof(ecc_pub));
  ret += security->get_publickey(ECC_SEC_P256R1, key_name, &out, &outlen);
  if (!out) {
    test_result++;
    see_selfprintf(" fail : %d\n", ret);
    security->remove_key(ECC_SEC_P256R1, key_name);
  } else {
    if (security->verify_ecdsa_signature(ECC_SEC_P256R1, key_name, hash, 32,
        sig, siglen) != 0)
      see_selfprintf("Signature verification fail\n");

    ret += security->remove_key(ECC_SEC_P256R1, key_name);
    see_selfprintf("[%d] ", cnt++);
    if (ret || memcmp(out, ecc_pub, sizeof(ecc_pub))) {
      test_result++;
      see_selfprintf(" fail : %d\n", ret);
    } else {
      see_selfprintf(" success\n");
    }

    free(out);
    out = NULL;
  }

  ret = security->set_key(RSA_1024, key_name, rsa1024_pub, sizeof(rsa1024_pub));
  ret += security->get_publickey(RSA_1024, key_name, &out, &outlen);
  if (!out) {
    test_result++;
    see_selfprintf(" fail : %d\n", ret);
  } else {
    ret += security->remove_key(RSA_1024, key_name);
    see_selfprintf("[%d] ", cnt++);
    if (ret || memcmp(out, rsa1024_pub, sizeof(rsa1024_pub))) {
      test_result++;
      see_selfprintf(" fail : %d\n", ret);
    } else {
      see_selfprintf(" success\n");
    }

    free(out);
    out = NULL;
  }

  for (i = 0; i < 9; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_DEFAULT, i);

    for (j = 0; j < 6; j++) {
      if (genkey_input[j][0] == RSA_1024 || genkey_input[j][0] == RSA_2048) {
        rsa_param.exponent_size = 4;
        rsa_param.exponent = exp;
      }

      ret = security->generate_key((see_algorithm)genkey_input[j][0],
                                   key_name, &rsa_param);
      ret += security->get_publickey((see_algorithm)genkey_input[j][0],
                                     key_name, &out, &outlen);
      ret += security->remove_key((see_algorithm)genkey_input[j][0], key_name);

      see_selfprintf("[%d] ", cnt++);

      if (i == 8 && ret) {
        see_selfprintf(" success\n");
      } else if (ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }
    }
  }

  /*
   * Does not support RSA in encrypted key
   */
  for (i = 0; i < 4; i++) {
    memset(key_name, 0, sizeof(key_name));
    snprintf(key_name, sizeof(key_name), "%s/%X", SECURE_STORAGE_MEMORY, i);

    for (j = 0; j < 6; j++) {
      if (genkey_input[j][0] == RSA_1024 || genkey_input[j][0] == RSA_2048)
        rsa_param.exponent = exp;

      ret = security->generate_key((see_algorithm)genkey_input[j][0],
                                   key_name, &rsa_param);
      ret += security->get_publickey((see_algorithm)genkey_input[j][0],
                                     key_name, &out, &outlen);
      ret += security->remove_key((see_algorithm)genkey_input[j][0], key_name);

      see_selfprintf("[%d] ", cnt++);

      if ((j == 4 || j == 5) && ret) {
        see_selfprintf(" success\n");
      } else if (ret) {
        test_result++;
        see_selfprintf(" fail\n");
      } else {
        see_selfprintf(" success\n");
      }

      if (out != NULL) {
        free(out);
        out = NULL;
      }
    }
  }

  if (out != NULL) {
    free(out);
    out = NULL;
  }

  return test_result;
}

int main(int argc, char **argv) {
  unsigned int i;
  char *p, *q;
  int test_result = 0;
  unsigned int test_select = 0xFFFF;

  for (i = 1; i < (unsigned int)argc; i++) {
    p = argv[i];
    q = strchr(p, '=');
    if (q == NULL)
      break;

    *q++ = '\0';

    if ((strcmp(p, "test_select")) == 0)
      test_select = atoi(q);
  }

  unsigned char test_name[][50] = {
    "security_get_certificates",
    "security_serial",
    "security_rand",
    "security_cert_publickey",
    "security_rsa_encrypt_decrypt",
    "security_aes_encrypt_decrypt",
    "security_secure_storage",
    "security_generate_key",
    "security_setup_remove_key",
    "security_get_hash",
    "security_get_hmac",
    "security_rsassa_sign_verify",
    "security_ecdsa_sign_verify",
    "security_set_compute_dhm_params",
    "security_set_compute_ecdh_params",
    "security_get_publickey"
  };

  printf("\n\n");

  try {
    artik::Security security;

    if (test_select & 0x1)
      if (security_get_certificates(&security))
        test_result |= 0x1;

    if (test_select & 0x4)
      if (security_rand(&security))
        test_result |= 0x4;

    if (test_select & 0x10)
      if (security_rsa_encrypt_decrypt(&security))
        test_result |= 0x10;

    if (test_select & 0x20)
      if (security_aes_encrypt_decrypt(&security))
        test_result |= 0x20;

    if (test_select & 0x40)
      if (security_secure_storage(&security))
        test_result |= 0x40;

    if (test_select & 0x80)
      if (security_generate_key(&security))
        test_result |= 0x80;

    if (test_select & 0x100)
      if (security_setup_remove_key(&security))
        test_result |= 0x100;

    if (test_select & 0x200)
      if (security_get_hash(&security))
        test_result |= 0x200;

    if (test_select & 0x400)
      if (security_get_hmac(&security))
        test_result |= 0x400;

    if (test_select & 0x800)
      if (security_rsassa_sign_verify(&security))
        test_result |= 0x800;

    if (test_select & 0x1000)
      if (security_ecdsa_sign_verify(&security))
        test_result |= 0x1000;

    if (test_select & 0x2000)
      if (security_set_compute_dhm_params(&security))
        test_result |= 0x2000;

    if (test_select & 0x4000)
      if (security_set_compute_ecdh_params(&security))
        test_result |= 0x4000;

    if (test_select & 0x8000)
      if (security_get_publickey(&security))
        test_result |= 0x8000;

    // Test Result
    for (i = 0; i < ARRAY_SIZE(test_name); i++) {
      if (!(test_select & 0x1))
        printf("%40s not tested\n", test_name[i]);
      else if (test_result & 0x1)
        printf("%40s fail\n", test_name[i]);
      else
        printf("%40s success\n", test_name[i]);
      test_result = test_result >> 1;
      test_select = test_select >> 1;
    }
  } catch (artik::ArtikException &e) {
    fprintf(stderr, "[Exception] : %s\n", e.what());
  }

  return 0;
}

